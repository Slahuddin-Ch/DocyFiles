<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Monero: RandomX</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Monero
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">RandomX </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>RandomX is a proof of work (PoW) algorithm which was designed to close the gap between general-purpose CPUs and specialized hardware. The core of the algorithm is a simulation of a virtual CPU.</p>
<h4>Table of contents</h4>
<ol type="1">
<li><a href="../../#1-definitions">Definitions</a></li>
</ol>
<ol type="1">
<li><a href="../../#2-algorithm-description">Algorithm description</a></li>
</ol>
<ol type="1">
<li><a href="../../#3-custom-functions">Custom functions</a></li>
</ol>
<ol type="1">
<li><a href="../../#4-virtual-machine">Virtual Machine</a></li>
</ol>
<ol type="1">
<li><a href="../../#5-instruction-set">Instruction set</a></li>
</ol>
<ol type="1">
<li><a href="../../#6-superscalarhash">SuperscalarHash</a></li>
</ol>
<ol type="1">
<li><a href="../../#7-dataset">Dataset</a></li>
</ol>
<h2>1. Definitions</h2>
<h3>1.1 General definitions</h3>
<p><b>Hash256</b> and <b>Hash512</b> refer to the <a href="https://blake2.net/blake2_20130129.pdf">Blake2b</a> hashing function with a 256-bit and 512-bit output size, respectively.</p>
<p><b>Floating point format</b> refers to the <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">IEEE-754 double precision floating point format</a> with a sign bit, 11-bit exponent and 52-bit fraction.</p>
<p><b>Argon2d</b> is a tradeoff-resistant variant of <a href="https://github.com/P-H-C/phc-winner-argon2/blob/master/argon2-specs.pdf">Argon2</a>, a memory-hard password derivation function.</p>
<p><b>AesGenerator1R</b> refers to an AES-based pseudo-random number generator described in chapter 3.2. It's initialized with a 512-bit seed value and is capable of producing more than 10 bytes per clock cycle.</p>
<p><b>AesGenerator4R</b> is a slower but more secure AES-based pseudo-random number generator described in chapter 3.3. It's initialized with a 512-bit seed value.</p>
<p><b>AesHash1R</b> refers to an AES-based fingerprinting function described in chapter 3.4. It's capable of processing more than 10 bytes per clock cycle and produces a 512-bit output.</p>
<p><b>BlakeGenerator</b> refers to a custom pseudo-random number generator described in chapter 3.5. It's based on the Blake2b hashing function.</p>
<p><b>SuperscalarHash</b> refers to a custom diffusion function designed to run efficiently on superscalar CPUs (see chapter 7). It transforms a 64-byte input value into a 64-byte output value.</p>
<p><b>Virtual Machine</b> or <b>VM</b> refers to the RandomX virtual machine as described in chapter 4.</p>
<p><b>Programming the VM</b> refers to the act of loading a program and configuration into the VM. This is described in chapter 4.5.</p>
<p><b>Executing the VM</b> refers to the act of running the program loop as described in chapter 4.6.</p>
<p><b>Scratchpad</b> refers to the workspace memory of the VM. The whole scratchpad is structured into 3 levels: L3 -&gt; L2 -&gt; L1 with each lower level being a subset of the higher levels.</p>
<p><b>Register File</b> refers to a 256-byte sequence formed by concatenating VM registers in little-endian format in the following order: <code>r0</code>-<code>r7</code>, <code>f0</code>-<code>f3</code>, <code>e0</code>-<code>e3</code> and <code>a0</code>-<code>a3</code>.</p>
<p><b>Program Buffer</b> refers to the buffer from which the VM reads instructions.</p>
<p><b>Cache</b> refers to a read-only buffer initialized by Argon2d as described in chapter 7.1.</p>
<p><b>Dataset</b> refers to a large read-only buffer described in chapter 7. It is constructed from the Cache using the SuperscalarHash function.</p>
<h3>1.2 Configurable parameters</h3>
<p>RandomX has several configurable parameters that are listed in Table 1.2.1 with their default values.</p>
<p><em>Table 1.2.1 - Configurable parameters</em></p>
<table class="doxtable">
<tr>
<th>parameter</th><th>description</th><th>default value  </th></tr>
<tr>
<td><code>RANDOMX_ARGON_MEMORY</code></td><td>The number of 1 KiB Argon2 blocks in the Cache</td><td><code>262144</code> </td></tr>
<tr>
<td><code>RANDOMX_ARGON_ITERATIONS</code></td><td>The number of Argon2d iterations for Cache initialization</td><td><code>3</code> </td></tr>
<tr>
<td><code>RANDOMX_ARGON_LANES</code></td><td>The number of parallel lanes for Cache initialization</td><td><code>1</code> </td></tr>
<tr>
<td><code>RANDOMX_ARGON_SALT</code></td><td>Argon2 salt</td><td><code>"RandomX\x03"</code> </td></tr>
<tr>
<td><code>RANDOMX_CACHE_ACCESSES</code></td><td>The number of random Cache accesses per Dataset item</td><td><code>8</code> </td></tr>
<tr>
<td><code>RANDOMX_SUPERSCALAR_LATENCY</code></td><td>Target latency for SuperscalarHash (in cycles of the reference CPU)</td><td><code>170</code> </td></tr>
<tr>
<td><code>RANDOMX_DATASET_BASE_SIZE</code></td><td>Dataset base size in bytes</td><td><code>2147483648</code> </td></tr>
<tr>
<td><code>RANDOMX_DATASET_EXTRA_SIZE</code></td><td>Dataset extra size in bytes</td><td><code>33554368</code> </td></tr>
<tr>
<td><code>RANDOMX_PROGRAM_SIZE</code></td><td>The number of instructions in a RandomX program</td><td><code>256</code> </td></tr>
<tr>
<td><code>RANDOMX_PROGRAM_ITERATIONS</code></td><td>The number of iterations per program</td><td><code>2048</code> </td></tr>
<tr>
<td><code>RANDOMX_PROGRAM_COUNT</code></td><td>The number of programs per hash</td><td><code>8</code> </td></tr>
<tr>
<td><code>RANDOMX_JUMP_BITS</code></td><td>Jump condition mask size in bits</td><td><code>8</code> </td></tr>
<tr>
<td><code>RANDOMX_JUMP_OFFSET</code></td><td>Jump condition mask offset in bits</td><td><code>8</code> </td></tr>
<tr>
<td><code>RANDOMX_SCRATCHPAD_L3</code></td><td>Scratchpad L3 size in bytes</td><td><code>2097152</code> </td></tr>
<tr>
<td><code>RANDOMX_SCRATCHPAD_L2</code></td><td>Scratchpad L2 size in bytes</td><td><code>262144</code> </td></tr>
<tr>
<td><code>RANDOMX_SCRATCHPAD_L1</code></td><td>Scratchpad L1 size in bytes</td><td><code>16384</code> </td></tr>
</table>
<p>Instruction frequencies listed in Tables 5.2.1, 5.3.1, 5.4.1 and 5.5.1 are also configurable.</p>
<h2>2. Algorithm description</h2>
<p>The RandomX algorithm accepts two input values:</p>
<ul>
<li>String <code>K</code> with a size of 0-60 bytes (key)</li>
<li>String <code>H</code> of arbitrary length (the value to be hashed)</li>
</ul>
<p>and outputs a 256-bit result <code>R</code>.</p>
<p>The algorithm consists of the following steps:</p>
<ol type="1">
<li>The Dataset is initialized using the key value <code>K</code> (described in chapter 7).</li>
</ol>
<ol type="1">
<li>64-byte seed <code>S</code> is calculated as <code>S = Hash512(H)</code>.</li>
</ol>
<ol type="1">
<li>Let <code>gen1 = AesGenerator1R(S)</code>.</li>
</ol>
<ol type="1">
<li>The Scratchpad is filled with <code>RANDOMX_SCRATCHPAD_L3</code> random bytes using generator <code>gen1</code>.</li>
</ol>
<ol type="1">
<li>Let <code>gen4 = AesGenerator4R(gen1.state)</code> (use the final state of <code>gen1</code>).</li>
</ol>
<ol type="1">
<li>The value of the VM register <code>fprc</code> is set to 0 (default rounding mode - chapter 4.3).</li>
</ol>
<ol type="1">
<li>The VM is programmed using <code>128 + 8 * RANDOMX_PROGRAM_SIZE</code> random bytes using generator <code>gen4</code> (chapter 4.5).</li>
</ol>
<ol type="1">
<li>The VM is executed (chapter 4.6).</li>
</ol>
<ol type="1">
<li>A new 64-byte seed is calculated as <code>S = Hash512(RegisterFile)</code>.</li>
</ol>
<ol type="1">
<li>Set <code>gen4.state = S</code> (modify the state of the generator).</li>
</ol>
<ol type="1">
<li>Steps 7-10 are performed a total of <code>RANDOMX_PROGRAM_COUNT</code> times. The last iteration skips steps 9 and 10.</li>
</ol>
<ol type="1">
<li>Scratchpad fingerprint is calculated as <code>A = AesHash1R(Scratchpad)</code>.</li>
</ol>
<ol type="1">
<li>Bytes 192-255 of the Register File are set to the value of <code>A</code>.</li>
</ol>
<ol type="1">
<li>Result is calculated as <code>R = Hash256(RegisterFile)</code>.</li>
</ol>
<p>The input of the <code>Hash512</code> function in step 9 is the following 256 bytes: </p><div class="fragment"><div class="line">+---------------------------------+</div><div class="line">|         registers r0-r7         | (64 bytes)</div><div class="line">+---------------------------------+</div><div class="line">|         registers f0-f3         | (64 bytes)</div><div class="line">+---------------------------------+</div><div class="line">|         registers e0-e3         | (64 bytes)</div><div class="line">+---------------------------------+</div><div class="line">|         registers a0-a3         | (64 bytes)</div><div class="line">+---------------------------------+</div></div><!-- fragment --><p>The input of the <code>Hash256</code> function in step 14 is the following 256 bytes: </p><div class="fragment"><div class="line">+---------------------------------+</div><div class="line">|         registers r0-r7         | (64 bytes)</div><div class="line">+---------------------------------+</div><div class="line">|         registers f0-f3         | (64 bytes)</div><div class="line">+---------------------------------+</div><div class="line">|         registers e0-e3         | (64 bytes)</div><div class="line">+---------------------------------+</div><div class="line">|      AesHash1R(Scratchpad)      | (64 bytes)</div><div class="line">+---------------------------------+</div></div><!-- fragment --><h2>3 Custom functions</h2>
<h3>3.1 Definitions</h3>
<p>Two of the custom functions are based on the <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">Advanced Encryption Standard</a> (AES).</p>
<p><b>AES encryption round</b> refers to the application of the ShiftRows, SubBytes and MixColumns transformations followed by a XOR with the round key.</p>
<p><b>AES decryption round</b> refers to the application of inverse ShiftRows, inverse SubBytes and inverse MixColumns transformations followed by a XOR with the round key.</p>
<h3>3.2 AesGenerator1R</h3>
<p>AesGenerator1R produces a sequence of pseudo-random bytes.</p>
<p>The internal state of the generator consists of 64 bytes arranged into four columns of 16 bytes each. During each output iteration, every column is decrypted (columns 0, 2) or encrypted (columns 1, 3) with one AES round using the following round keys (one key per column):</p>
<div class="fragment"><div class="line">key0 = 53 a5 ac 6d 09 66 71 62 2b 55 b5 db 17 49 f4 b4</div><div class="line">key1 = 07 af 7c 6d 0d 71 6a 84 78 d3 25 17 4e dc a1 0d</div><div class="line">key2 = f1 62 12 3f c6 7e 94 9f 4f 79 c0 f4 45 e3 20 3e</div><div class="line">key3 = 35 81 ef 6a 7c 31 ba b1 88 4c 31 16 54 91 16 49</div></div><!-- fragment --><p> These keys were generated as: </p><div class="fragment"><div class="line">key0, key1, key2, key3 = Hash512(&quot;RandomX AesGenerator1R keys&quot;)</div></div><!-- fragment --><p>Single iteration produces 64 bytes of output which also become the new generator state. </p><div class="fragment"><div class="line">state0 (16 B)    state1 (16 B)    state2 (16 B)    state3 (16 B)</div><div class="line">     |                |                |                |</div><div class="line"> AES decrypt      AES encrypt      AES decrypt      AES encrypt</div><div class="line">   (key0)           (key1)           (key2)           (key3)</div><div class="line">     |                |                |                |</div><div class="line">     v                v                v                v</div><div class="line">  state0&#39;          state1&#39;          state2&#39;          state3&#39;</div></div><!-- fragment --><h3>3.3 AesGenerator4R</h3>
<p>AesGenerator4R works similar way as AesGenerator1R, except it uses 4 rounds per column. Columns 0 and 1 use a different set of keys than columns 2 and 3.</p>
<div class="fragment"><div class="line">state0 (16 B)    state1 (16 B)    state2 (16 B)    state3 (16 B)</div><div class="line">     |                |                |                |</div><div class="line"> AES decrypt      AES encrypt      AES decrypt      AES encrypt</div><div class="line">   (key0)           (key0)           (key4)           (key4)</div><div class="line">     |                |                |                |</div><div class="line">     v                v                v                v</div><div class="line"> AES decrypt      AES encrypt      AES decrypt      AES encrypt</div><div class="line">   (key1)           (key1)           (key5)           (key5)</div><div class="line">     |                |                |                |</div><div class="line">     v                v                v                v</div><div class="line"> AES decrypt      AES encrypt      AES decrypt      AES encrypt</div><div class="line">   (key2)           (key2)           (key6)           (key6)</div><div class="line">     |                |                |                |</div><div class="line">     v                v                v                v</div><div class="line"> AES decrypt      AES encrypt      AES decrypt      AES encrypt</div><div class="line">   (key3)           (key3)           (key7)           (key7)</div><div class="line">     |                |                |                |</div><div class="line">     v                v                v                v</div><div class="line">  state0&#39;          state1&#39;          state2&#39;          state3&#39;</div></div><!-- fragment --><p>AesGenerator4R uses the following 8 round keys:</p>
<div class="fragment"><div class="line">key0 = dd aa 21 64 db 3d 83 d1 2b 6d 54 2f 3f d2 e5 99</div><div class="line">key1 = 50 34 0e b2 55 3f 91 b6 53 9d f7 06 e5 cd df a5</div><div class="line">key2 = 04 d9 3e 5c af 7b 5e 51 9f 67 a4 0a bf 02 1c 17</div><div class="line">key3 = 63 37 62 85 08 5d 8f e7 85 37 67 cd 91 d2 de d8</div><div class="line">key4 = 73 6f 82 b5 a6 a7 d6 e3 6d 8b 51 3d b4 ff 9e 22</div><div class="line">key5 = f3 6b 56 c7 d9 b3 10 9c 4e 4d 02 e9 d2 b7 72 b2</div><div class="line">key6 = e7 c9 73 f2 8b a3 65 f7 0a 66 a9 2b a7 ef 3b f6</div><div class="line">key7 = 09 d6 7c 7a de 39 58 91 fd d1 06 0c 2d 76 b0 c0</div></div><!-- fragment --><p> These keys were generated as: </p><div class="fragment"><div class="line">key0, key1, key2, key3 = Hash512(&quot;RandomX AesGenerator4R keys 0-3&quot;)</div><div class="line">key4, key5, key6, key7 = Hash512(&quot;RandomX AesGenerator4R keys 4-7&quot;)</div></div><!-- fragment --><h3>3.4 AesHash1R</h3>
<p>AesHash1R calculates a 512-bit fingerprint of its input.</p>
<p>AesHash1R has a 64-byte internal state, which is arranged into four columns of 16 bytes each. The initial state is:</p>
<div class="fragment"><div class="line">state0 = 0d 2c b5 92 de 56 a8 9f 47 db 82 cc ad 3a 98 d7</div><div class="line">state1 = 6e 99 8d 33 98 b7 c7 15 5a 12 9e f5 57 80 e7 ac</div><div class="line">state2 = 17 00 77 6a d0 c7 62 ae 6b 50 79 50 e4 7c a0 e8</div><div class="line">state3 = 0c 24 0a 63 8d 82 ad 07 05 00 a1 79 48 49 99 7e</div></div><!-- fragment --><p>The initial state vectors were generated as: </p><div class="fragment"><div class="line">state0, state1, state2, state3 = Hash512(&quot;RandomX AesHash1R state&quot;)</div></div><!-- fragment --><p>The input is processed in 64-byte blocks. Each input block is considered to be a set of four AES round keys <code>key0</code>, <code>key1</code>, <code>key2</code>, <code>key3</code>. Each state column is encrypted (columns 0, 2) or decrypted (columns 1, 3) with one AES round using the corresponding round key:</p>
<div class="fragment"><div class="line">state0 (16 B)    state1 (16 B)    state2 (16 B)    state3 (16 B)</div><div class="line">     |                |                |                |</div><div class="line"> AES encrypt      AES decrypt      AES encrypt      AES decrypt</div><div class="line">   (key0)           (key1)           (key2)           (key3)</div><div class="line">     |                |                |                |</div><div class="line">     v                v                v                v</div><div class="line">  state0&#39;          state1&#39;          state2&#39;          state3&#39;</div></div><!-- fragment --><p>When all input bytes have been processed, the state is processed with two additional AES rounds with the following extra keys (one key per round, same pair of keys for all columns):</p>
<div class="fragment"><div class="line">xkey0 = 89 83 fa f6 9f 94 24 8b bf 56 dc 90 01 02 89 06</div><div class="line">xkey1 = d1 63 b2 61 3c e0 f4 51 c6 43 10 ee 9b f9 18 ed</div></div><!-- fragment --><p>The extra keys were generated as: </p><div class="fragment"><div class="line">xkey0, xkey1 = Hash256(&quot;RandomX AesHash1R xkeys&quot;)</div></div><!-- fragment --><div class="fragment"><div class="line">state0 (16 B)    state1 (16 B)    state2 (16 B)    state3 (16 B)</div><div class="line">     |                |                |                |</div><div class="line"> AES encrypt      AES decrypt      AES encrypt      AES decrypt</div><div class="line">   (xkey0)          (xkey0)          (xkey0)          (xkey0)</div><div class="line">     |                |                |                |</div><div class="line">     v                v                v                v</div><div class="line"> AES encrypt      AES decrypt      AES encrypt      AES decrypt</div><div class="line">   (xkey1)          (xkey1)          (xkey1)          (xkey1)</div><div class="line">     |                |                |                |</div><div class="line">     v                v                v                v</div><div class="line">finalState0      finalState1      finalState2      finalState3 </div></div><!-- fragment --><p>The final state is the output of the function.</p>
<h3>3.5 BlakeGenerator</h3>
<p>BlakeGenerator is a simple pseudo-random number generator based on the Blake2b hashing function. It has a 64-byte internal state <code>S</code>.</p>
<h4>3.5.1 Initialization</h4>
<p>The internal state is initialized from a seed value <code>K</code> (0-60 bytes long). The seed value is written into the internal state and padded with zeroes. Then the internal state is initialized as <code>S = Hash512(S)</code>.</p>
<h4>3.5.2 <a class="el" href="../../d5/d78/classRandom.html">Random</a> number generation</h4>
<p>The generator can generate 1 byte or 4 bytes at a time by supplying data from its internal state <code>S</code>. If there are not enough unused bytes left, the internal state is reinitialized as <code>S = Hash512(S)</code>.</p>
<h2>4. Virtual Machine</h2>
<p>The components of the RandomX virtual machine are summarized in Fig. 4.1.</p>
<p><em>Figure 4.1 - Virtual Machine</em></p>
<div class="image">
<img src="https://i.imgur.com/Enk42b8.png" alt="Imgur"/>
</div>
<p>The VM is a complex instruction set computer (<a href="https://en.wikipedia.org/wiki/Complex_instruction_set_computer">CISC</a>). All data are loaded and stored in little-endian byte order. Signed integer numbers are represented using <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two's complement</a>.</p>
<h3>4.1 Dataset</h3>
<p>Dataset is described in detail in chapter 7. It's a large read-only buffer. Its size is equal to <code>RANDOMX_DATASET_BASE_SIZE + RANDOMX_DATASET_EXTRA_SIZE</code> bytes. Each program uses only a random subset of the Dataset of size <code>RANDOMX_DATASET_BASE_SIZE</code>. All Dataset accesses read an aligned 64-byte item.</p>
<h3>4.2 Scratchpad</h3>
<p>Scratchpad represents the workspace memory of the VM. Its size is <code>RANDOMX_SCRATCHPAD_L3</code> bytes and it's divided into 3 "levels":</p>
<ul>
<li>The whole scratchpad is the third level "L3".</li>
<li>The first <code>RANDOMX_SCRATCHPAD_L2</code> bytes of the scratchpad is the second level "L2".</li>
<li>The first <code>RANDOMX_SCRATCHPAD_L1</code> bytes of the scratchpad is the first level "L1".</li>
</ul>
<p>The scratchpad levels are inclusive, i.e. L3 contains both L2 and L1 and L2 contains L1.</p>
<p>To access a particular scratchpad level, bitwise AND with a mask according to table 4.2.1 is applied to the memory address.</p>
<p><em>Table 4.2.1: Scratchpad access masks</em></p>
<table class="doxtable">
<tr>
<th>Level</th><th>8-byte aligned mask</th><th>64-byte aligned mask  </th></tr>
<tr>
<td>L1</td><td><code>(RANDOMX_SCRATCHPAD_L1 - 1) &amp; ~7</code></td><td>- </td></tr>
<tr>
<td>L2</td><td><code>(RANDOMX_SCRATCHPAD_L2 - 1) &amp; ~7</code></td><td>- </td></tr>
<tr>
<td>L3</td><td><code>(RANDOMX_SCRATCHPAD_L3 - 1) &amp; ~7</code></td><td><code>(RANDOMX_SCRATCHPAD_L3 - 1) &amp; ~63</code> </td></tr>
</table>
<h3>4.3 Registers</h3>
<p>The VM has 8 integer registers <code>r0</code>-<code>r7</code> (group R) and a total of 12 floating point registers split into 3 groups: <code>f0</code>-<code>f3</code> (group F), <code>e0</code>-<code>e3</code> (group E) and <code>a0</code>-<code>a3</code> (group A). Integer registers are 64 bits wide, while floating point registers are 128 bits wide and contain a pair of numbers in floating point format. The lower and upper half of floating point registers are not separately addressable.</p>
<p>Additionally, there are 3 internal registers <code>ma</code>, <code>mx</code> and <code>fprc</code>.</p>
<p>Integer registers <code>r0</code>-<code>r7</code> can be the source or the destination operands of integer instructions or may be used as address registers for accessing the Scratchpad.</p>
<p>Floating point registers <code>a0</code>-<code>a3</code> are read-only and their value is fixed for a given VM program. They can be the source operand of any floating point instruction. The value of these registers is restricted to the interval <code>[1, 4294967296)</code>.</p>
<p>Floating point registers <code>f0</code>-<code>f3</code> are the "additive" registers, which can be the destination of floating point addition and subtraction instructions. The absolute value of these registers will not exceed about <code>3.0e+14</code>.</p>
<p>Floating point registers <code>e0</code>-<code>e3</code> are the "multiplicative" registers, which can be the destination of floating point multiplication, division and square root instructions. Their value is always positive.</p>
<p><code>ma</code> and <code>mx</code> are the memory registers. Both are 32 bits wide. <code>ma</code> contains the memory address of the next Dataset read and <code>mx</code> contains the address of the next Dataset prefetch. The values of <code>ma</code> and <code>mx</code> registers are always aligned to be a multiple of 64.</p>
<p>The 2-bit <code>fprc</code> register determines the rounding mode of all floating point operations according to Table 4.3.1. The four rounding modes are defined by the IEEE 754 standard.</p>
<p><em>Table 4.3.1: Rounding modes</em></p>
<table class="doxtable">
<tr>
<th><code>fprc</code></th><th>rounding mode  </th></tr>
<tr>
<td>0</td><td>roundTiesToEven </td></tr>
<tr>
<td>1</td><td>roundTowardNegative </td></tr>
<tr>
<td>2</td><td>roundTowardPositive </td></tr>
<tr>
<td>3</td><td>roundTowardZero </td></tr>
</table>
<h4>4.3.1 <a class="el" href="../../d4/d91/structGroup.html">Group</a> F register conversion</h4>
<p>When an 8-byte value read from the memory is to be converted to an F group register value or operand, it is interpreted as a pair of 32-bit signed integers (in little endian, two's complement format) and converted to floating point format. This conversion is exact and doesn't need rounding because only 30 bits of the fraction significand are needed to represent the integer value.</p>
<h4>4.3.2 <a class="el" href="../../d4/d91/structGroup.html">Group</a> E register conversion</h4>
<p>When an 8-byte value read from the memory is to be converted to an E group register value or operand, the same conversion procedure is applied as for F group registers (see 4.3.1) with additional post-processing steps for each of the two floating point values:</p>
<ol type="1">
<li>The sign bit is set to <code>0</code>.</li>
<li>Bits 0-2 of the exponent are set to the constant value of <code>011<sub>2</sub></code>.</li>
<li>Bits 3-6 of the exponent are set to the value of the exponent mask described in chapter 4.5.6. This value is fixed for a given VM program.</li>
<li>The bottom 22 bits of the fraction significand are set to the value of the fraction mask described in chapter 4.5.6. This value is fixed for a given VM program.</li>
</ol>
<h3>4.4 Program buffer</h3>
<p>The Program buffer stores the program to be executed by the VM. The program consists of <code>RANDOMX_PROGRAM_SIZE</code> instructions. Each instruction is encoded by an 8-byte word. The instruction set is described in chapter 5.</p>
<h3>4.5 VM programming</h3>
<p>The VM requires <code>128 + 8 * RANDOMX_PROGRAM_SIZE</code> bytes to be programmed. This is split into two parts:</p>
<ul>
<li><code>128</code> bytes of configuration data = 16 quadwords (16×8 bytes), used according to Table 4.5.1</li>
<li><code>8 * RANDOMX_PROGRAM_SIZE</code> bytes of program data, copied directly into the Program Buffer</li>
</ul>
<p><em>Table 4.5.1 - Configuration data</em></p>
<table class="doxtable">
<tr>
<th>quadword</th><th>description  </th></tr>
<tr>
<td>0</td><td>initialize low half of register <code>a0</code> </td></tr>
<tr>
<td>1</td><td>initialize high half of register <code>a0</code> </td></tr>
<tr>
<td>2</td><td>initialize low half of register <code>a1</code> </td></tr>
<tr>
<td>3</td><td>initialize high half of register <code>a1</code> </td></tr>
<tr>
<td>4</td><td>initialize low half of register <code>a2</code> </td></tr>
<tr>
<td>5</td><td>initialize high half of register <code>a2</code> </td></tr>
<tr>
<td>6</td><td>initialize low half of register <code>a3</code> </td></tr>
<tr>
<td>7</td><td>initialize high half of register <code>a3</code> </td></tr>
<tr>
<td>8</td><td>initialize register <code>ma</code> </td></tr>
<tr>
<td>9</td><td>(reserved) </td></tr>
<tr>
<td>10</td><td>initialize register <code>mx</code> </td></tr>
<tr>
<td>11</td><td>(reserved) </td></tr>
<tr>
<td>12</td><td>select address registers </td></tr>
<tr>
<td>13</td><td>select Dataset offset </td></tr>
<tr>
<td>14</td><td>initialize register masks for low half of group E registers </td></tr>
<tr>
<td>15</td><td>initialize register masks for high half of group E registers </td></tr>
</table>
<h4>4.5.2 <a class="el" href="../../d4/d91/structGroup.html">Group</a> A register initialization</h4>
<p>The values of the floating point registers <code>a0</code>-<code>a3</code> are initialized using configuration quadwords 0-7 to have the following value:</p>
<p><code>+1.fraction x 2<sup>exponent</sup></code></p>
<p>The fraction has full 52 bits of precision and the exponent value ranges from 0 to 31. These values are obtained from the initialization quadword (in little endian format) according to Table 4.5.2.</p>
<p><em>Table 4.5.2 - <a class="el" href="../../d4/d91/structGroup.html">Group</a> A register initialization</em></p>
<table class="doxtable">
<tr>
<th>bits</th><th>description  </th></tr>
<tr>
<td>0-51</td><td>fraction </td></tr>
<tr>
<td>52-58</td><td>(reserved) </td></tr>
<tr>
<td>59-63</td><td>exponent </td></tr>
</table>
<h4>4.5.3 Memory registers</h4>
<p>Registers <code>ma</code> and <code>mx</code> are initialized using the low 32 bits of quadwords 8 and 10 in little endian format.</p>
<h4>4.5.4 Address registers</h4>
<p>Bits 0-3 of quadword 12 are used to select 4 address registers for program execution. Each bit chooses one register from a pair of integer registers according to Table 4.5.3.</p>
<p><em>Table 4.5.3 - Address registers</em></p>
<table class="doxtable">
<tr>
<th>address register (bit)</th><th>value = 0</th><th>value = 1  </th></tr>
<tr>
<td><code>readReg0</code> (0)</td><td><code>r0</code></td><td><code>r1</code> </td></tr>
<tr>
<td><code>readReg1</code> (1)</td><td><code>r2</code></td><td><code>r3</code> </td></tr>
<tr>
<td><code>readReg2</code> (2)</td><td><code>r4</code></td><td><code>r5</code> </td></tr>
<tr>
<td><code>readReg3</code> (3)</td><td><code>r6</code></td><td><code>r7</code> </td></tr>
</table>
<h4>4.5.5 Dataset offset</h4>
<p>The <code>datasetOffset</code> is calculated as the remainder of dividing quadword 13 by <code>RANDOMX_DATASET_EXTRA_SIZE / 64 + 1</code>. The result is multiplied by <code>64</code>. This offset is used when reading values from the Dataset.</p>
<h4>4.5.6 <a class="el" href="../../d4/d91/structGroup.html">Group</a> E register masks</h4>
<p>These masks are used for the conversion of group E registers (see 4.3.2). The low and high halves each have their own masks initialized from quadwords 14 and 15. The fraction mask is given by bits 0-21 and the exponent mask by bits 60-63 of the initialization quadword.</p>
<h3>4.6 VM execution</h3>
<p>During VM execution, 3 additional temporary registers are used: <code>ic</code>, <code>spAddr0</code> and <code>spAddr1</code>. Program execution consists of initialization and loop execution.</p>
<h4>4.6.1 Initialization</h4>
<ol type="1">
<li><code>ic</code> register is set to <code>RANDOMX_PROGRAM_ITERATIONS</code>.</li>
<li><code>spAddr0</code> is set to the value of <code>mx</code>.</li>
<li><code>spAddr1</code> is set to the value of <code>ma</code>.</li>
<li>The values of all integer registers <code>r0</code>-<code>r7</code> are set to zero.</li>
</ol>
<h4>4.6.2 Loop execution</h4>
<p>The loop described below is repeated until the value of the <code>ic</code> register reaches zero.</p>
<ol type="1">
<li>XOR of registers <code>readReg0</code> and <code>readReg1</code> (see Table 4.5.3) is calculated and <code>spAddr0</code> is XORed with the low 32 bits of the result and <code>spAddr1</code> with the high 32 bits.</li>
<li><code>spAddr0</code> is used to perform a 64-byte aligned read from Scratchpad level 3 (using mask from Table 4.2.1). The 64 bytes are XORed with all integer registers in order <code>r0</code>-<code>r7</code>.</li>
<li><code>spAddr1</code> is used to perform a 64-byte aligned read from Scratchpad level 3 (using mask from Table 4.2.1). Each floating point register <code>f0</code>-<code>f3</code> and <code>e0</code>-<code>e3</code> is initialized using an 8-byte value according to the conversion rules from chapters 4.3.1 and 4.3.2.</li>
<li>The 256 instructions stored in the Program Buffer are executed.</li>
<li>The <code>mx</code> register is XORed with the low 32 bits of registers <code>readReg2</code> and <code>readReg3</code> (see Table 4.5.3).</li>
<li>A 64-byte Dataset item at address <code>datasetOffset + mx % RANDOMX_DATASET_BASE_SIZE</code> is prefetched from the Dataset (it will be used during the next iteration).</li>
<li>A 64-byte Dataset item at address <code>datasetOffset + ma % RANDOMX_DATASET_BASE_SIZE</code> is loaded from the Dataset. The 64 bytes are XORed with all integer registers in order <code>r0</code>-<code>r7</code>.</li>
<li>The values of registers <code>mx</code> and <code>ma</code> are swapped.</li>
<li>The values of all integer registers <code>r0</code>-<code>r7</code> are written to the Scratchpad (L3) at address <code>spAddr1</code> (64-byte aligned).</li>
<li>Register <code>f0</code> is XORed with register <code>e0</code> and the result is stored in register <code>f0</code>. Register <code>f1</code> is XORed with register <code>e1</code> and the result is stored in register <code>f1</code>. Register <code>f2</code> is XORed with register <code>e2</code> and the result is stored in register <code>f2</code>. Register <code>f3</code> is XORed with register <code>e3</code> and the result is stored in register <code>f3</code>.</li>
<li>The values of registers <code>f0</code>-<code>f3</code> are written to the Scratchpad (L3) at address <code>spAddr0</code> (64-byte aligned).</li>
<li><code>spAddr0</code> and <code>spAddr1</code> are both set to zero.</li>
<li><code>ic</code> is decreased by 1.</li>
</ol>
<h2>5. Instruction set</h2>
<p>The VM executes programs in a special instruction set, which was designed in such way that any random 8-byte word is a valid instruction and any sequence of valid instructions is a valid program. Because there are no "syntax" rules, generating a random program is as easy as filling the program buffer with random data.</p>
<h3>5.1 Instruction encoding</h3>
<p>Each instruction word is 64 bits long. Instruction fields are encoded as shown in Fig. 5.1.</p>
<p><em>Figure 5.1 - Instruction encoding</em></p>
<div class="image">
<img src="https://i.imgur.com/FtkWRwe.png" alt="Imgur"/>
</div>
<h4>5.1.1 opcode</h4>
<p>There are 256 opcodes, which are distributed between 29 distinct instructions. Each instruction can be encoded using multiple opcodes (the number of opcodes specifies the frequency of the instruction in a random program).</p>
<p><em>Table 5.1.1: Instruction groups</em></p>
<table class="doxtable">
<tr>
<th>group</th><th># instructions</th><th># opcodes</th><th></th></tr>
<tr>
<td>integer </td><td>17</td><td>120</td><td>46.9% </td></tr>
<tr>
<td>floating point </td><td>9</td><td>94</td><td>36.7% </td></tr>
<tr>
<td>control </td><td>2</td><td>26</td><td>10.2% </td></tr>
<tr>
<td>store </td><td>1</td><td>16</td><td>6.2% </td></tr>
<tr>
<td></td><td>**29**</td><td>**256**</td><td>**100%** </td></tr>
</table>
<p>All instructions are described below in chapters 5.2 - 5.5.</p>
<h4>5.1.2 dst</h4>
<p>Destination register. Only bits 0-1 (register groups A, F, E) or 0-2 (groups R, F+E) are used to encode a register according to Table 5.1.2.</p>
<p><em>Table 5.1.2: Addressable register groups</em></p>
<table class="doxtable">
<tr>
<th>index</th><th>R</th><th>A</th><th>F</th><th>E</th><th>F+E  </th></tr>
<tr>
<td>0</td><td><code>r0</code></td><td><code>a0</code></td><td><code>f0</code></td><td><code>e0</code></td><td><code>f0</code> </td></tr>
<tr>
<td>1</td><td><code>r1</code></td><td><code>a1</code></td><td><code>f1</code></td><td><code>e1</code></td><td><code>f1</code> </td></tr>
<tr>
<td>2</td><td><code>r2</code></td><td><code>a2</code></td><td><code>f2</code></td><td><code>e2</code></td><td><code>f2</code> </td></tr>
<tr>
<td>3</td><td><code>r3</code></td><td><code>a3</code></td><td><code>f3</code></td><td><code>e3</code></td><td><code>f3</code> </td></tr>
<tr>
<td>4</td><td><code>r4</code></td><td></td><td></td><td></td><td><code>e0</code> </td></tr>
<tr>
<td>5</td><td><code>r5</code></td><td></td><td></td><td></td><td><code>e1</code> </td></tr>
<tr>
<td>6</td><td><code>r6</code></td><td></td><td></td><td></td><td><code>e2</code> </td></tr>
<tr>
<td>7</td><td><code>r7</code></td><td></td><td></td><td></td><td><code>e3</code> </td></tr>
</table>
<h4>5.1.3 src</h4>
<p>The <code>src</code> flag encodes a source operand register according to Table 5.1.2 (only bits 0-1 or 0-2 are used).</p>
<p>Some integer instructions use a constant value as the source operand in cases when <code>dst</code> and <code>src</code> encode the same register (see Table 5.2.1).</p>
<p>For register-memory instructions, the source operand is used to calculate the memory address.</p>
<h4>5.1.4 mod</h4>
<p>The <code>mod</code> flag is encoded as:</p>
<p><em>Table 5.1.3: mod flag encoding</em></p>
<table class="doxtable">
<tr>
<th><code>mod</code> bits</th><th>description</th><th>range of values  </th></tr>
<tr>
<td>0-1</td><td><code>mod.mem</code> flag</td><td>0-3 </td></tr>
<tr>
<td>2-3</td><td><code>mod.shift</code> flag</td><td>0-3 </td></tr>
<tr>
<td>4-7</td><td><code>mod.cond</code> flag</td><td>0-15 </td></tr>
</table>
<p>The <code>mod.mem</code> flag selects between Scratchpad levels L1 and L2 when reading from or writing to memory except for two cases:</p>
<ul>
<li>it's a memory read and <code>dst</code> and <code>src</code> encode the same register</li>
<li>it's a memory write <code>mod.cond</code> is 14 or 15</li>
</ul>
<p>In these two cases, the Scratchpad level is L3 (see Table 5.1.4).</p>
<p><em>Table 5.1.4: memory access Scratchpad level</em></p>
<table class="doxtable">
<tr>
<th>condition</th><th>Scratchpad level  </th></tr>
<tr>
<td><code>src == dst</code> (read)</td><td>L3 </td></tr>
<tr>
<td><code>mod.cond &gt;= 14</code> (write)</td><td>L3 </td></tr>
<tr>
<td><code>mod.mem == 0</code></td><td>L2 </td></tr>
<tr>
<td><code>mod.mem != 0</code></td><td>L1 </td></tr>
</table>
<p>The address for reading/writing is calculated by applying bitwise AND operation to the address and the 8-byte aligned address mask listed in Table 4.2.1.</p>
<p>The <code>mod.cond</code> and <code>mod.shift</code> flags are used by some instructions (see 5.2, 5.4).</p>
<h4>5.1.5 imm32</h4>
<p>A 32-bit immediate value that can be used as the source operand and is used to calculate addresses for memory operations. The immediate value is sign-extended to 64 bits unless specified otherwise.</p>
<h3>5.2 Integer instructions</h3>
<p>For integer instructions, the destination is always an integer register (register group R). Source operand (if applicable) can be either an integer register or memory value. If <code>dst</code> and <code>src</code> refer to the same register, most instructions use <code>0</code> or <code>imm32</code> instead of the register. This is indicated in the 'src == dst' column in Table 5.2.1.</p>
<p><code>[mem]</code> indicates a memory operand loaded as an 8-byte value from the address <code>src + imm32</code>.</p>
<p><em>Table 5.2.1 Integer instructions</em></p>
<table class="doxtable">
<tr>
<th>frequency</th><th>instruction</th><th>dst</th><th>src</th><th><code>src == dst ?</code></th><th>operation  </th></tr>
<tr>
<td>16/256</td><td>IADD_RS</td><td>R</td><td>R</td><td><code>src = dst</code></td><td><code>dst = dst + (src &lt;&lt; mod.shift) (+ imm32)</code> </td></tr>
<tr>
<td>7/256</td><td>IADD_M</td><td>R</td><td>R</td><td><code>src = 0</code></td><td><code>dst = dst + [mem]</code> </td></tr>
<tr>
<td>16/256</td><td>ISUB_R</td><td>R</td><td>R</td><td><code>src = imm32</code></td><td><code>dst = dst - src</code> </td></tr>
<tr>
<td>7/256</td><td>ISUB_M</td><td>R</td><td>R</td><td><code>src = 0</code></td><td><code>dst = dst - [mem]</code> </td></tr>
<tr>
<td>16/256</td><td>IMUL_R</td><td>R</td><td>R</td><td><code>src = imm32</code></td><td><code>dst = dst * src</code> </td></tr>
<tr>
<td>4/256</td><td>IMUL_M</td><td>R</td><td>R</td><td><code>src = 0</code></td><td><code>dst = dst * [mem]</code> </td></tr>
<tr>
<td>4/256</td><td>IMULH_R</td><td>R</td><td>R</td><td><code>src = dst</code></td><td><code>dst = (dst * src) &gt;&gt; 64</code> </td></tr>
<tr>
<td>1/256</td><td>IMULH_M</td><td>R</td><td>R</td><td><code>src = 0</code></td><td><code>dst = (dst * [mem]) &gt;&gt; 64</code> </td></tr>
<tr>
<td>4/256</td><td>ISMULH_R</td><td>R</td><td>R</td><td><code>src = dst</code></td><td><code>dst = (dst * src) &gt;&gt; 64</code> (signed) </td></tr>
<tr>
<td>1/256</td><td>ISMULH_M</td><td>R</td><td>R</td><td><code>src = 0</code></td><td><code>dst = (dst * [mem]) &gt;&gt; 64</code> (signed) </td></tr>
<tr>
<td>8/256</td><td>IMUL_RCP</td><td>R</td><td>-</td><td>-</td><td><code>dst = 2<sup>x</sup> / imm32 * dst</code> </td></tr>
<tr>
<td>2/256</td><td>INEG_R</td><td>R</td><td>-</td><td>-</td><td><code>dst = -dst</code> </td></tr>
<tr>
<td>15/256</td><td>IXOR_R</td><td>R</td><td>R</td><td><code>src = imm32</code></td><td><code>dst = dst ^ src</code> </td></tr>
<tr>
<td>5/256</td><td>IXOR_M</td><td>R</td><td>R</td><td><code>src = 0</code></td><td><code>dst = dst ^ [mem]</code> </td></tr>
<tr>
<td>8/256</td><td>IROR_R</td><td>R</td><td>R</td><td><code>src = imm32</code></td><td><code>dst = dst &gt;&gt;&gt; src</code> </td></tr>
<tr>
<td>2/256</td><td>IROL_R</td><td>R</td><td>R</td><td><code>src = imm32</code></td><td><code>dst = dst &lt;&lt;&lt; src</code> </td></tr>
<tr>
<td>4/256</td><td>ISWAP_R</td><td>R</td><td>R</td><td><code>src = dst</code></td><td><code>temp = src; src = dst; dst = temp</code> </td></tr>
</table>
<h4>5.2.1 IADD_RS</h4>
<p>This instructions adds the values of two registers (modulo 2<sup>64</sup>). The value of the second operand is shifted left by 0-3 bits (determined by the <code>mod.shift</code> flag). Additionally, if <code>dst</code> is register <code>r5</code>, the immediate value <code>imm32</code> is added to the result.</p>
<h4>5.2.2 IADD_M</h4>
<p>64-bit integer addition operation (performed modulo 2<sup>64</sup>) with a memory source operand.</p>
<h4>5.2.3 ISUB_R, ISUB_M</h4>
<p>64-bit integer subtraction (performed modulo 2<sup>64</sup>). ISUB_R uses register source operand, ISUB_M uses a memory source operand.</p>
<h4>5.2.4 IMUL_R, IMUL_M</h4>
<p>64-bit integer multiplication (performed modulo 2<sup>64</sup>). IMUL_R uses a register source operand, IMUL_M uses a memory source operand.</p>
<h4>5.2.5 IMULH_R, IMULH_M, ISMULH_R, ISMULH_M</h4>
<p>These instructions output the high 64 bits of the whole 128-bit multiplication result. The result differs for signed and unsigned multiplication (IMULH is unsigned, ISMULH is signed). The variants with a register source operand perform a squaring operation if <code>dst</code> equals <code>src</code>.</p>
<h4>5.2.6 IMUL_RCP</h4>
<p>If <code>imm32</code> equals 0 or is a power of 2, IMUL_RCP is a no-op. In other cases, the instruction multiplies the destination register by a reciprocal of <code>imm32</code> (the immediate value is zero-extended and treated as unsigned). The reciprocal is calculated as <code>rcp = 2<sup>x</sup> / imm32</code> by choosing the largest integer <code>x</code> such that <code>rcp &lt; 2<sup>64</sup></code>.</p>
<h4>5.2.7 INEG_R</h4>
<p>Performs two's complement negation of the destination register.</p>
<h4>5.2.8 IXOR_R, IXOR_M</h4>
<p>64-bit exclusive OR operation. IXOR_R uses a register source operand, IXOR_M uses a memory source operand.</p>
<h4>5.2.9 IROR_R, IROL_R</h4>
<p>Performs a cyclic shift (rotation) of the destination register. Source operand (shift count) is implicitly masked to 6 bits. IROR rotates bits right, IROL left.</p>
<h4>5.2.9 ISWAP_R</h4>
<p>This instruction swaps the values of two registers. If source and destination refer to the same register, the result is a no-op.</p>
<h3>5.3 Floating point instructions</h3>
<p>For floating point instructions, the destination can be a group F or group E register. Source operand is either a group A register or a memory value.</p>
<p><code>[mem]</code> indicates a memory operand loaded as an 8-byte value from the address <code>src + imm32</code> and converted according to the rules in chapters 4.3.1 (group F) or 4.3.2 (group E). The lower and upper memory operands are denoted as <code>[mem][0]</code> and <code>[mem][1]</code>.</p>
<p>All floating point operations are rounded according to the current value of the <code>fprc</code> register (see Table 4.3.1). Due to restrictions on the values of the floating point registers, no operation results in <code>NaN</code> or a denormal number.</p>
<p><em>Table 5.3.1 Floating point instructions</em></p>
<table class="doxtable">
<tr>
<th>frequency</th><th>instruction</th><th>dst</th><th>src</th><th>operation  </th></tr>
<tr>
<td>4/256</td><td>FSWAP_R</td><td>F+E</td><td>-</td><td><code>(dst0, dst1) = (dst1, dst0)</code> </td></tr>
<tr>
<td>16/256</td><td>FADD_R</td><td>F</td><td>A</td><td><code>(dst0, dst1) = (dst0 + src0, dst1 + src1)</code> </td></tr>
<tr>
<td>5/256</td><td>FADD_M</td><td>F</td><td>R</td><td><code>(dst0, dst1) = (dst0 + [mem][0], dst1 + [mem][1])</code> </td></tr>
<tr>
<td>16/256</td><td>FSUB_R</td><td>F</td><td>A</td><td><code>(dst0, dst1) = (dst0 - src0, dst1 - src1)</code> </td></tr>
<tr>
<td>5/256</td><td>FSUB_M</td><td>F</td><td>R</td><td><code>(dst0, dst1) = (dst0 - [mem][0], dst1 - [mem][1])</code> </td></tr>
<tr>
<td>6/256</td><td>FSCAL_R</td><td>F</td><td>-</td><td><code>(dst0, dst1) = (-2<sup>x0</sup> * dst0, -2<sup>x1</sup> * dst1)</code> </td></tr>
<tr>
<td>32/256</td><td>FMUL_R</td><td>E</td><td>A</td><td><code>(dst0, dst1) = (dst0 * src0, dst1 * src1)</code> </td></tr>
<tr>
<td>4/256</td><td>FDIV_M</td><td>E</td><td>R</td><td><code>(dst0, dst1) = (dst0 / [mem][0], dst1 / [mem][1])</code> </td></tr>
<tr>
<td>6/256</td><td>FSQRT_R</td><td>E</td><td>-</td><td><code>(dst0, dst1) = (√dst0, √dst1)</code> </td></tr>
</table>
<h4>5.3.1 FSWAP_R</h4>
<p>Swaps the lower and upper halves of the destination register. This is the only instruction that is applicable to both F an E register groups.</p>
<h4>5.3.2 FADD_R, FADD_M</h4>
<p>Double precision floating point addition. FADD_R uses a group A register source operand, FADD_M uses a memory operand.</p>
<h4>5.3.3 FSUB_R, FSUB_M</h4>
<p>Double precision floating point subtraction. FSUB_R uses a group A register source operand, FSUB_M uses a memory operand.</p>
<h4>5.3.4 FSCAL_R</h4>
<p>This instruction negates the number and multiplies it by <code>2<sup>x</sup></code>. <code>x</code> is calculated by taking the 4 least significant digits of the biased exponent and interpreting them as a binary number using the digit set <code>{+1, -1}</code> as opposed to the traditional <code>{0, 1}</code>. The possible values of <code>x</code> are all odd numbers from -15 to +15.</p>
<p>The mathematical operation described above is equivalent to a bitwise XOR of the binary representation with the value of <code>0x80F0000000000000</code>.</p>
<h4>5.3.5 FMUL_R</h4>
<p>Double precision floating point multiplication. This instruction uses only a register source operand.</p>
<h4>5.3.6 FDIV_M</h4>
<p>Double precision floating point division. This instruction uses only a memory source operand.</p>
<h4>5.3.7 FSQRT_R</h4>
<p>Double precision floating point square root of the destination register.</p>
<h3>5.4 Control instructions</h3>
<p>There are 2 control instructions.</p>
<p><em>Table 5.4.1 - Control instructions</em></p>
<table class="doxtable">
<tr>
<th>frequency</th><th>instruction</th><th>dst</th><th>src</th><th>operation  </th></tr>
<tr>
<td>1/256</td><td>CFROUND</td><td>-</td><td>R</td><td><code>fprc = src &gt;&gt;&gt; imm32</code> </td></tr>
<tr>
<td>25/256</td><td>CBRANCH</td><td>R</td><td>-</td><td><code>dst = dst + cimm</code>, conditional jump </td></tr>
</table>
<h4>5.4.1 CFROUND</h4>
<p>This instruction calculates a 2-bit value by rotating the source register right by <code>imm32</code> bits and taking the 2 least significant bits (the value of the source register is unaffected). The result is stored in the <code>fprc</code> register. This changes the rounding mode of all subsequent floating point instructions.</p>
<h4>5.4.2 CBRANCH</h4>
<p>This instruction adds an immediate value <code>cimm</code> (constructed from <code>imm32</code>, see below) to the destination register and then performs a conditional jump in the Program Buffer based on the value of the destination register. The target of the jump is the instruction following the instruction when register <code>dst</code> was last modified.</p>
<p>At the beginning of each program iteration, all registers are considered to be unmodified. A register is considered as modified by an instruction in the following cases:</p>
<ul>
<li>It is the destination register of an integer instruction except IMUL_RCP and ISWAP_R.</li>
<li>It is the destination register of IMUL_RCP and <code>imm32</code> is not zero or a power of 2.</li>
<li>It is the source or the destination register of ISWAP_R and the destination and source registers are distinct.</li>
<li>The CBRANCH instruction is considered to modify all integer registers.</li>
</ul>
<p>If register <code>dst</code> has not been modified yet, the jump target is the first instruction in the Program Buffer.</p>
<p>The CBRANCH instruction performs the following steps:</p>
<ol type="1">
<li>A constant <code>b</code> is calculated as <code>mod.cond + RANDOMX_JUMP_OFFSET</code>.</li>
</ol>
<ol type="1">
<li>A constant <code>cimm</code> is constructed as sign-extended <code>imm32</code> with bit <code>b</code> set to 1 and bit <code>b-1</code> set to 0 (if <code>b &gt; 0</code>).</li>
</ol>
<ol type="1">
<li><code>cimm</code> is added to the destination register.</li>
</ol>
<ol type="1">
<li>If bits <code>b</code> to <code>b + RANDOMX_JUMP_BITS - 1</code> of the destination register are zero, the jump is executed (target is the instruction following the instruction where <code>dst</code> was last modified).</li>
</ol>
<p>Bits in immediate and register values are numbered from 0 to 63 with 0 being the least significant bit. For example, for <code>b = 10</code> and <code>RANDOMX_JUMP_BITS = 8</code>, the bits are arranged like this:</p>
<div class="fragment"><div class="line">cimm = SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSMMMMMMMMMMMMMMMMMMMMM10MMMMMMMMM</div><div class="line"> dst = ..............................................XXXXXXXX..........</div></div><!-- fragment --><p><code>S</code> is a copied sign bit from <code>imm32</code>. <code>M</code> denotes bits of <code>imm32</code>. The 9th bit is set to 0 and the 10th bit is set to 1. This value will be added to <code>dst</code>.</p>
<p>The second line uses <code>X</code> to mark bits of <code>dst</code> that will be checked by the condition. If all these bits are 0 after adding <code>cimm</code>, the jump is executed.</p>
<p>The construction of the CBRANCH instruction ensures that no inifinite loops are possible in the program.</p>
<h3>5.5 Store instruction</h3>
<p>There is one explicit store instruction for integer values.</p>
<p><code>[mem]</code> indicates the destination is an 8-byte value at the address <code>dst + imm32</code>.</p>
<p><em>Table 5.5.1 - Store instruction</em></p>
<table class="doxtable">
<tr>
<th>frequency</th><th>instruction</th><th>dst</th><th>src</th><th>operation  </th></tr>
<tr>
<td>16/256</td><td>ISTORE</td><td>R</td><td>R</td><td><code>[mem] = src</code> </td></tr>
</table>
<h4>5.5.1 ISTORE</h4>
<p>This instruction stores the value of the source integer register to the memory at the address calculated from the value of the destination register. The <code>src</code> and <code>dst</code> can be the same register.</p>
<h2>6. SuperscalarHash</h2>
<p>SuperscalarHash is a custom diffusion function that was designed to burn as much power as possible using only the CPU's integer ALUs.</p>
<p>The input and output of SuperscalarHash are 8 integer registers <code>r0</code>-<code>r7</code>, each 64 bits wide. The output of SuperscalarHash is used to construct the Dataset (see chapter 7.3).</p>
<h3>6.1 Instructions</h3>
<p>The body of SuperscalarHash is a random sequence of instructions that can run on the Virtual Machine. SuperscalarHash uses a reduced set of only integer register-register instructions listed in Table 6.1.1. <code>dst</code> refers to the destination register, <code>src</code> to the source register.</p>
<p><em>Table 6.1.1 - SuperscalarHash instructions</em></p>
<table class="doxtable">
<tr>
<th>freq. †</th><th>instruction</th><th>Macro-ops</th><th>operation</th><th>rules  </th></tr>
<tr>
<td>0.11</td><td>ISUB_R</td><td><code>sub_rr</code></td><td><code>dst = dst - src</code></td><td><code>dst != src</code> </td></tr>
<tr>
<td>0.11</td><td>IXOR_R</td><td><code>xor_rr</code></td><td><code>dst = dst ^ src</code></td><td><code>dst != src</code> </td></tr>
<tr>
<td>0.11</td><td>IADD_RS</td><td><code>lea_sib</code></td><td><code>dst = dst + (src &lt;&lt; mod.shift)</code></td><td><code>dst != src</code>, <code>dst != r5</code> </td></tr>
<tr>
<td>0.22</td><td>IMUL_R</td><td><code>imul_rr</code></td><td><code>dst = dst * src</code></td><td><code>dst != src</code> </td></tr>
<tr>
<td>0.11</td><td>IROR_C</td><td><code>ror_ri</code></td><td><code>dst = dst &gt;&gt;&gt; imm32</code></td><td><code>imm32 % 64 != 0</code> </td></tr>
</table>
<p>|0.10|IADD_C|<code>add_ri</code>|<code>dst = dst + imm32</code>| |0.10|IXOR_C|<code>xor_ri</code>|<code>dst = dst ^ imm32</code>| |0.03|IMULH_R|<code>mov_rr</code>,<code>mul_r</code>,<code>mov_rr</code>|<code>dst = (dst * src) &gt;&gt; 64</code>| |0.03|ISMULH_R|<code>mov_rr</code>,<code>imul_r</code>,<code>mov_rr</code>|<code>dst = (dst * src) &gt;&gt; 64</code> (signed)| |0.06|IMUL_RCP|<code>mov_ri</code>,<code>imul_rr</code>|<code>dst = 2<sup>x</sup> / imm32 * dst</code>|<code>imm32 != 0</code>, <code>imm32 != 2<sup>N</sup></code>|</p>
<p>† Frequencies are approximate. Instructions are generated based on complex rules.</p>
<h4>6.1.1 ISUB_R</h4>
<p>See chapter 5.2.3. Source and destination are always distinct registers.</p>
<h4>6.1.2 IXOR_R</h4>
<p>See chapter 5.2.8. Source and destination are always distinct registers.</p>
<h4>6.1.3 IADD_RS</h4>
<p>See chapter 5.2.1. Source and destination are always distinct registers and register <code>r5</code> cannot be the destination.</p>
<h4>6.1.4 IMUL_R</h4>
<p>See chapter 5.2.4. Source and destination are always distinct registers.</p>
<h4>6.1.5 IROR_C</h4>
<p>The destination register is rotated right. The rotation count is given by <code>imm32</code> masked to 6 bits and cannot be 0.</p>
<h4>6.1.6 IADD_C</h4>
<p>A sign-extended <code>imm32</code> is added to the destination register.</p>
<h4>6.1.7 IXOR_C</h4>
<p>The destination register is XORed with a sign-extended <code>imm32</code>.</p>
<h4>6.1.8 IMULH_R, ISMULH_R</h4>
<p>See chapter 5.2.5.</p>
<h4>6.1.9 IMUL_RCP</h4>
<p>See chapter 5.2.6. <code>imm32</code> is never 0 or a power of 2.</p>
<h3>6.2 The reference CPU</h3>
<p>Unlike a standard RandomX program, a SuperscalarHash program is generated using a strict set of rules to achieve the maximum performance on a superscalar CPU. For this purpose, the generator runs a simulation of a reference CPU.</p>
<p>The reference CPU is loosely based on the <a href="https://en.wikipedia.org/wiki/Ivy_Bridge_(microarchitecture)">Intel Ivy Bridge microarchitecture</a>. It has the following properties:</p>
<ul>
<li>The CPU has 3 integer execution ports P0, P1 and P5 that can execute instructions in parallel. Multiplication can run only on port P1.</li>
<li>Each of the Superscalar instructions listed in Table 6.1.1 consist of one or more <em>Macro-ops</em>. Each Macro-op has certain execution latency (in cycles) and size (in bytes) as shown in Table 6.2.1.</li>
<li>Each of the Macro-ops listed in Table 6.2.1 consists of 0-2 <em>Micro-ops</em> that can go to a subset of the 3 execution ports. If a Macro-op consists of 2 Micro-ops, both must be executed together.</li>
<li>The CPU can decode at most 16 bytes of code per cycle and at most 4 Micro-ops per cycle.</li>
</ul>
<p><em>Table 6.2.1 - Macro-ops</em></p>
<table class="doxtable">
<tr>
<th>Macro-op</th><th>latency</th><th>size</th><th>1st Micro-op</th><th>2nd Micro-op  </th></tr>
<tr>
<td><code>sub_rr</code></td><td>1</td><td>3</td><td>P015</td><td>- </td></tr>
<tr>
<td><code>xor_rr</code></td><td>1</td><td>3</td><td>P015</td><td>- </td></tr>
<tr>
<td><code>lea_sib</code></td><td>1</td><td>4</td><td>P01</td><td>- </td></tr>
<tr>
<td><code>imul_rr</code></td><td>3</td><td>4</td><td>P1</td><td>- </td></tr>
<tr>
<td><code>ror_ri</code></td><td>1</td><td>4</td><td>P05</td><td>- </td></tr>
<tr>
<td><code>add_ri</code></td><td>1</td><td>7, 8, 9</td><td>P015</td><td>- </td></tr>
<tr>
<td><code>xor_ri</code></td><td>1</td><td>7, 8, 9</td><td>P015</td><td>- </td></tr>
<tr>
<td><code>mov_rr</code></td><td>0</td><td>3</td><td>-</td><td>- </td></tr>
<tr>
<td><code>mul_r</code></td><td>4</td><td>3</td><td>P1</td><td>P5 </td></tr>
<tr>
<td><code>imul_r</code></td><td>4</td><td>3</td><td>P1</td><td>P5 </td></tr>
<tr>
<td><code>mov_ri</code></td><td>1</td><td>10</td><td>P015</td><td>- </td></tr>
</table>
<ul>
<li>P015 - Micro-op can be executed on any port</li>
<li>P01 - Micro-op can be executed on ports P0 or P1</li>
<li>P05 - Micro-op can be executed on ports P0 or P5</li>
<li>P1 - Micro-op can be executed only on port P1</li>
<li>P5 - Micro-op can be executed only on port P5</li>
</ul>
<p>Macro-ops <code>add_ri</code> and <code>xor_ri</code> can be optionally padded to a size of 8 or 9 bytes for code alignment purposes. <code>mov_rr</code> has 0 execution latency and doesn't use an execution port, but still occupies space during the decoding stage (see chapter 6.3.1).</p>
<h3>6.3 CPU simulation</h3>
<p>SuperscalarHash programs are generated to maximize the usage of all 3 execution ports of the reference CPU. The generation consists of 4 stages:</p>
<ul>
<li>Decoding stage</li>
<li>Instruction selection</li>
<li>Port assignment</li>
<li>Operand assignment</li>
</ul>
<p>Program generation is complete when one of two conditions is met:</p>
<ol type="1">
<li>An instruction is scheduled for execution on cycle that is equal to or greater than <code>RANDOMX_SUPERSCALAR_LATENCY</code></li>
</ol>
<ol type="1">
<li>The number of generated instructions reaches <code>3 * RANDOMX_SUPERSCALAR_LATENCY + 2</code>.</li>
</ol>
<h4>6.3.1 Decoding stage</h4>
<p>The generator produces instructions in groups of 3 or 4 Macro-op slots such that the size of each group is exactly 16 bytes.</p>
<p><em>Table 6.3.1 - Decoder configurations</em></p>
<table class="doxtable">
<tr>
<th>decoder group</th><th>configuration  </th></tr>
<tr>
<td>0</td><td>4-8-4 </td></tr>
<tr>
<td>1</td><td>7-3-3-3 </td></tr>
<tr>
<td>2</td><td>3-7-3-3 </td></tr>
<tr>
<td>3</td><td>4-9-3 </td></tr>
<tr>
<td>4</td><td>4-4-4-4 </td></tr>
<tr>
<td>5</td><td>3-3-10 </td></tr>
</table>
<p>The rules for the selection of the decoder group are following:</p>
<ul>
<li>If the currently processed instruction is IMULH_R or ISMULH_R, the next decode group is group 5 (the only group that starts with a 3-byte slot and has only 3 slots).</li>
<li>If the total number of multiplications that have been generated is less than or equal to the current decoding cycle, the next decode group is group 4.</li>
<li>If the currently processed instruction is IMUL_RCP, the next decode group is group 0 or 3 (must begin with a 4-byte slot for multiplication).</li>
<li>Otherwise a random decode group is selected from groups 0-3.</li>
</ul>
<h4>6.3.2 Instruction selection</h4>
<p>Instructions are selected based on the size of the current decode group slot - see Table 6.3.2.</p>
<p><em>Table 6.3.2 - Decoder configurations</em></p>
<table class="doxtable">
<tr>
<th>slot size</th><th>note</th><th>instructions  </th></tr>
<tr>
<td>3</td><td>-</td><td>ISUB_R, IXOR_R </td></tr>
<tr>
<td>3</td><td>last slot in the group</td><td>ISUB_R, IXOR_R, IMULH_R, ISMULH_R </td></tr>
<tr>
<td>4</td><td>decode group 4, not the last slot</td><td>IMUL_R </td></tr>
<tr>
<td>4</td><td>-</td><td>IROR_C, IADD_RS </td></tr>
<tr>
<td>7,8,9</td><td>-</td><td>IADD_C, IXOR_C </td></tr>
<tr>
<td>10</td><td>-</td><td>IMUL_RCP </td></tr>
</table>
<h4>6.3.3 Port assignment</h4>
<p>Micro-ops are issued to execution ports as soon as an available port is free. The scheduling is done optimistically by checking port availability in order P5 -&gt; P0 -&gt; P1 to not overload port P1 (multiplication) by instructions that can go to any port. The cycle when all Micro-ops of an instruction can be executed is called the 'scheduleCycle'.</p>
<h4>6.3.4 Operand assignment</h4>
<p>The source operand (if needed) is selected first. is it selected from the group of registers that are available at the 'scheduleCycle' of the instruction. A register is available if the latency of its last operation has elapsed.</p>
<p>The destination operand is selected with more strict rules (see column 'rules' in Table 6.1.1):</p>
<ul>
<li>value must be ready at the required cycle</li>
<li>cannot be the same as the source register unless the instruction allows it (see column 'rules' in Table 6.1.1)<ul>
<li>this avoids optimizable operations such as <code>reg ^ reg</code> or <code>reg - reg</code></li>
<li>it also increases intermixing of register values</li>
</ul>
</li>
<li>register cannot be multiplied twice in a row unless <code>allowChainedMul</code> is true<ul>
<li>this avoids accumulation of trailing zeroes in registers due to excessive multiplication</li>
<li><code>allowChainedMul</code> is set to true if an attempt to find source/destination registers failed (this is quite rare, but prevents a catastrophic failure of the generator)</li>
</ul>
</li>
<li>either the last instruction applied to the register or its source must be different than the current instruction<ul>
<li>this avoids optimizable instruction sequences such as <code>r1 = r1 ^ r2; r1 = r1 ^ r2</code> (can be eliminated) or <code>reg = reg &gt;&gt;&gt; C1; reg = reg &gt;&gt;&gt; C2</code> (can be reduced to one rotation) or <code>reg = reg + C1; reg = reg + C2</code> (can be reduced to one addition)</li>
</ul>
</li>
<li>register <code>r5</code> cannot be the destination of the IADD_RS instruction (limitation of the x86 lea instruction)</li>
</ul>
<h2>7. Dataset</h2>
<p>The Dataset is a read-only memory structure that is used during program execution (chapter 4.6.2, steps 6 and 7). The size of the Dataset is <code>RANDOMX_DATASET_BASE_SIZE + RANDOMX_DATASET_EXTRA_SIZE</code> bytes and it's divided into 64-byte 'items'.</p>
<p>In order to allow PoW verification with a lower amount of memory, the Dataset is constructed in two steps using an intermediate structure called the "Cache", which can be used to calculate Dataset items on the fly.</p>
<p>The whole Dataset is constructed from the key value <code>K</code>, which is an input parameter of RandomX. The whole Dataset needs to be recalculated everytime the key value changes. Fig. 7.1 shows the process of Dataset construction. Note: the maximum supported length of <code>K</code> is 60 bytes. Using a longer key results in implementation-defined behavior.</p>
<p><em>Figure 7.1 - Dataset construction</em></p>
<div class="image">
<img src="https://i.imgur.com/86h5SbW.png" alt="Imgur"/>
</div>
<h3>7.1 Cache construction</h3>
<p>The key <code>K</code> is expanded into the Cache using the "memory fill" function of Argon2d with parameters according to Table 7.1.1. The key is used as the "password" field.</p>
<p><em>Table 7.1.1 - Argon2 parameters</em></p>
<table class="doxtable">
<tr>
<th>parameter</th><th>value  </th></tr>
<tr>
<td>parallelism</td><td><code>RANDOMX_ARGON_LANES</code> </td></tr>
<tr>
<td>output size</td><td>0 </td></tr>
<tr>
<td>memory</td><td><code>RANDOMX_ARGON_MEMORY</code> </td></tr>
<tr>
<td>iterations</td><td><code>RANDOMX_ARGON_ITERATIONS</code> </td></tr>
<tr>
<td>version</td><td><code>0x13</code> </td></tr>
<tr>
<td>hash type</td><td>0 (Argon2d) </td></tr>
<tr>
<td>password</td><td>key value <code>K</code> </td></tr>
<tr>
<td>salt</td><td><code>RANDOMX_ARGON_SALT</code> </td></tr>
<tr>
<td>secret size</td><td>0 </td></tr>
<tr>
<td>assoc. data size</td><td>0 </td></tr>
</table>
<p>The finalizer and output calculation steps of Argon2 are omitted. The output is the filled memory array.</p>
<h3>7.2 SuperscalarHash initialization</h3>
<p>The key value <code>K</code> is used to initialize a BlakeGenerator (see chapter 3.5), which is then used to generate 8 SuperscalarHash instances for Dataset initialization.</p>
<h3>7.3 Dataset block generation</h3>
<p>Dataset items are numbered sequentially with <code>itemNumber</code> starting from 0. Each 64-byte Dataset item is generated independently using 8 SuperscalarHash functions (generated according to chapter 7.2) and by XORing randomly selected data from the Cache (constructed according to chapter 7.1).</p>
<p>The item data is represented by 8 64-bit integer registers: <code>r0</code>-<code>r7</code>.</p>
<ol type="1">
<li>The register values are initialized as follows (<code>*</code> = multiplication, <code>^</code> = XOR):<ul>
<li><code>r0 = (itemNumber + 1) * 6364136223846793005</code></li>
<li><code>r1 = r0 ^ 9298411001130361340</code></li>
<li><code>r2 = r0 ^ 12065312585734608966</code></li>
<li><code>r3 = r0 ^ 9306329213124626780</code></li>
<li><code>r4 = r0 ^ 5281919268842080866</code></li>
<li><code>r5 = r0 ^ 10536153434571861004</code></li>
<li><code>r6 = r0 ^ 3398623926847679864</code></li>
<li><code>r7 = r0 ^ 9549104520008361294</code></li>
</ul>
</li>
</ol>
<ol type="1">
<li>Let <code>cacheIndex = itemNumber</code></li>
</ol>
<ol type="1">
<li>Let <code>i = 0</code></li>
</ol>
<ol type="1">
<li>Load a 64-byte item from the Cache. The item index is given by <code>cacheIndex</code> modulo the total number of 64-byte items in Cache.</li>
</ol>
<ol type="1">
<li>Execute <code>SuperscalarHash[i](r0, r1, r2, r3, r4, r5, r6, r7)</code>, where <code>SuperscalarHash[i]</code> refers to the i-th SuperscalarHash function. This modifies the values of the registers <code>r0</code>-<code>r7</code>.</li>
</ol>
<ol type="1">
<li>XOR all registers with the 64 bytes loaded in step 4 (8 bytes per column in order <code>r0</code>-<code>r7</code>).</li>
</ol>
<ol type="1">
<li>Set <code>cacheIndex</code> to the value of the register that has the longest dependency chain in the SuperscalarHash function executed in step 5.</li>
</ol>
<ol type="1">
<li>Set <code>i = i + 1</code> and go back to step 4 if <code>i &lt; RANDOMX_CACHE_ACCESSES</code>.</li>
</ol>
<ol type="1">
<li>Concatenate registers <code>r0</code>-<code>r7</code> in little endian format to get the final Dataset item data.</li>
</ol>
<p>The constants used to initialize register values in step 1 were determined as follows:</p>
<ul>
<li>Multiplier <code>6364136223846793005</code> was selected because it gives an excellent distribution for linear generators (D. Knuth: The Art of Computer Programming – Vol 2., also listed in <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use">Commonly used LCG parameters</a>)</li>
<li>XOR constants used to initialize registers <code>r1</code>-<code>r7</code> were determined by calculating <code>Hash512</code> of the <a class="el" href="../../d3/d64/structASCII.html" title="ASCII encoding. ">ASCII</a> value <code>"RandomX SuperScalarHash initialize"</code> and taking bytes 8-63 as 7 little-endian unsigned 64-bit integers. Additionally, the constant for <code>r1</code> was increased by <code>2<sup>33</sup>+700</code> and the constant for <code>r3</code> was increased by <code>2<sup>14</sup></code> (these changes are necessary to ensure that all registers have unique initial values for all values of <code>itemNumber</code>). </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 2 2023 19:23:33 for Monero by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
