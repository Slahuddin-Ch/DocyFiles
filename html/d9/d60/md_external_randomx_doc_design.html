<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Monero: RandomX design</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Monero
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">RandomX design </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>To minimize the performance advantage of specialized hardware, a proof of work (PoW) algorithm must achieve <em>device binding</em> by targeting specific features of existing general-purpose hardware. This is a complex task because we have to target a large class of devices with different architectures from different manufacturers.</p>
<p>There are two distinct classes of general processing devices: central processing units (CPUs) and graphics processing units (GPUs). RandomX targets CPUs for the following reasons:</p>
<ul>
<li>CPUs, being less specialized devices, are more prevalent and widely accessible. A CPU-bound algorithm is more egalitarian and allows more participants to join the network. This is one of the goals stated in the original CryptoNote whitepaper [<a href="https://cryptonote.org/whitepaper.pdf">1</a>].</li>
<li>A large common subset of native hardware instructions exists among different CPU architectures. The same cannot be said about GPUs. For example, there is no common integer multiplication instruction for NVIDIA and AMD GPUs [<a href="https://github.com/ifdefelse/ProgPOW/issues/16">2</a>].</li>
<li>All major CPU instruction sets are well documented with multiple open source compilers available. In comparison, GPU instruction sets are usually proprietary and may require vendor specific closed-source drivers for maximum performance.</li>
</ul>
<h2>1. Design considerations</h2>
<p>The most basic idea of a CPU-bound proof of work is that the "work" must be dynamic. This takes advantage of the fact that CPUs accept two kinds of inputs: <em>data</em> (the main input) and <em>code</em> (which specifies what to perform with the data).</p>
<p>Conversely, typical cryptographic hashing functions [<a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">3</a>] do not represent suitable work for the CPU because their only input is <em>data</em>, while the sequence of operations is fixed and can be performed more efficiently by a specialized integrated circuit.</p>
<h3>1.1 Dynamic proof of work</h3>
<p>A dynamic proof of work algorithm can generally consist of the following 4 steps:</p>
<p>1) Generate a random program. 2) Translate it into the native machine code of the CPU. 3) Execute the program. 4) Transform the output of the program into a cryptographically secure value.</p>
<p>The actual 'useful' CPU-bound work is performed in step 3, so the algorithm must be tuned to minimize the overhead of the remaining steps.</p>
<h4>1.1.1 Generating a random program</h4>
<p>Early attempts at a dynamic proof of work design were based on generating a program in a high-level language, such as C or Javascript [<a href="https://github.com/hyc/randprog">4</a>, <a href="https://github.com/tevador/RandomJS">5</a>]. However, this is very inefficient for two main reasons:</p>
<ul>
<li>High level languages have a complex syntax, so generating a valid program is relatively slow since it requires the creation of an abstract syntax tree (ASL).</li>
<li>Once the source code of the program is generated, the compiler will generally parse the textual representation back into the ASL, which makes the whole process of generating source code redundant.</li>
</ul>
<p>The fastest way to generate a random program is to use a <em>logic-less</em> generator - simply filling a buffer with random data. This of course requires designing a syntaxless programming language (or instruction set) in which all random bit strings represent valid programs.</p>
<h4>1.1.2 Translating the program into machine code</h4>
<p>This step is inevitable because we don't want to limit the algorithm to a specific CPU architecture. In order to generate machine code as fast as possible, we need our instruction set to be as close to native hardware as possible, while still generic enough to support different architectures. There is not enough time for expensive optimizations during code compilation.</p>
<h4>1.1.3 Executing the program</h4>
<p>The actual program execution should utilize as many CPU components as possible. Some of the features that should be utilized in the program are:</p>
<ul>
<li>multi-level caches (L1, L2, L3)</li>
<li>μop cache [<a href="https://en.wikipedia.org/wiki/CPU_cache#Micro-operation_(%CE%BCop_or_uop)_cache">6</a>]</li>
<li>arithmetic logic unit (ALU)</li>
<li>floating point unit (FPU)</li>
<li>memory controller</li>
<li>instruction level parallelism [<a href="https://en.wikipedia.org/wiki/Instruction-level_parallelism">7</a>]<ul>
<li>superscalar execution [<a href="https://en.wikipedia.org/wiki/Superscalar_processor">8</a>]</li>
<li>out-of-order execution [<a href="https://en.wikipedia.org/wiki/Out-of-order_execution">9</a>]</li>
<li>speculative execution [<a href="https://en.wikipedia.org/wiki/Speculative_execution">10</a>]</li>
<li>register renaming [<a href="https://en.wikipedia.org/wiki/Register_renaming">11</a>]</li>
</ul>
</li>
</ul>
<p>Chapter 2 describes how the RandomX VM takes advantages of these features.</p>
<h4>1.1.4 Calculating the final result</h4>
<p>Blake2b [<a href="https://blake2.net/">12</a>] is a cryptographically secure hashing function that was specifically designed to be fast in software, especially on modern 64-bit processors, where it's around three times faster than SHA-3 and can run at a speed of around 3 clock cycles per byte of input. This function is an ideal candidate to be used in a CPU-friendly proof of work.</p>
<p>For processing larger amounts of data in a cryptographically secure way, the Advanced Encryption Standard (AES) [<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">13</a>] can provide the fastest processing speed because many modern CPUs support hardware acceleration of these operations. See chapter 3 for more details about the use of AES in RandomX.</p>
<h3>1.2 The "Easy program problem"</h3>
<p>When a random program is generated, one may choose to execute it only when it's favorable. This strategy is viable for two main reasons:</p>
<ol type="1">
<li>The runtime of randomly generated programs typically follows a log-normal distribution [<a href="https://en.wikipedia.org/wiki/Log-normal_distribution">14</a>] (also see Appendix C). A generated program may be quickly analyzed and if it's likely to have above-average runtime, program execution may be skipped and a new program may be generated instead. This can significantly boost performance especially in case the runtime distribution has a heavy tail (many long-running outliers) and if program generation is cheap.</li>
<li>An implementation may choose to optimize for a subset of the features required for program execution. For example, the support for some operations (such as division) may be dropped or some instruction sequences may be implemented more efficiently. Generated programs would then be analyzed and be executed only if they match the specific requirements of the optimized implementation.</li>
</ol>
<p>These strategies of searching for programs of particular properties deviate from the objectives of this proof of work, so they must be eliminated. This can be achieved by requiring a sequence of <em>N</em> random programs to be executed such that each program is generated from the output of the previous one. The output of the final program is then used as the result.</p>
<div class="fragment"><div class="line">          +---------------+     +---------------+               +---------------+     +---------------+</div><div class="line">          |               |     |               |               |               |     |               |</div><div class="line">input --&gt; |   program 1   | --&gt; |   program 2   | --&gt;  ...  --&gt; | program (N-1) | --&gt; |   program N   | --&gt; result</div><div class="line">          |               |     |               |               |               |     |               |</div><div class="line">          +---------------+     +---------------+               +---------------+     +---------------+</div></div><!-- fragment --><p>The principle is that after the first program is executed, a miner has to either commit to finishing the whole chain (which may include unfavorable programs) or start over and waste the effort expended on the unfinished chain. Examples of how this affects the hashrate of different mining strategies are given in Appendix A.</p>
<p>Additionally, this chained program execution has the benefit of equalizing the runtime for the whole chain since the relative deviation of a sum of identically distributed runtimes is decreased.</p>
<h3>1.3 Verification time</h3>
<p>Since the purpose of the proof of work is to be used in a trustless peer-to-peer network, network participants must be able to quickly verify if a proof is valid or not. This puts an upper bound on the complexity of the proof of work algorithm. In particular, we set a goal for RandomX to be at least as fast to verify as the CryptoNight hash function [<a href="https://cryptonote.org/cns/cns008.txt">15</a>], which it aims to replace.</p>
<h3>1.4 Memory-hardness</h3>
<p>Besides pure computational resources, such as ALUs and FPUs, CPUs usually have access to a large amount of memory in the form of DRAM [<a href="https://en.wikipedia.org/wiki/Dynamic_random-access_memory">16</a>]. The performance of the memory subsystem is typically tuned to match the compute capabilities, for example [<a href="https://en.wikipedia.org/wiki/Multi-channel_memory_architecture">17</a>]:</p>
<ul>
<li>single channel memory for embedded and low power CPUs</li>
<li>dual channel memory for desktop CPUs</li>
<li>triple or quad channel memory for workstation CPUs</li>
<li>six or eight channel memory for high-end server CPUs</li>
</ul>
<p>In order to utilize the external memory as well as the on-chip memory controllers, the proof of work algorithm should access a large memory buffer (called the "Dataset"). The Dataset must be:</p>
<ol type="1">
<li>larger than what can be stored on-chip (to require external memory)</li>
<li>dynamic (to require writable memory)</li>
</ol>
<p>The maximum amount of SRAM that can be put on a single chip is more than 512 MiB for a 16 nm process and more than 2 GiB for a 7 nm process [<a href="https://www.grin-forum.org/t/obelisk-grn1-chip-details/4571">18</a>]. Ideally, the size of the Dataset should be at least 4 GiB. However, due to constraints on the verification time (see below), the size used by RandomX was selected to be 2080 MiB. While a single chip can theoretically be made with this amount of SRAM using current technology (7 nm in 2019), the feasibility of such solution is questionable, at least in the near future.</p>
<h4>1.4.1 Light-client verification</h4>
<p>While it's reasonable to require &gt;2 GiB for dedicated mining systems that solve the proof of work, an option must be provided for light clients to verify the proof using a much lower amount of memory.</p>
<p>The ratio of memory required for the 'fast' and 'light' modes must be chosen carefully not to make the light mode viable for mining. In particular, the area-time (AT) product of the light mode should not be smaller than the AT product of the fast mode. Reduction of the AT product is a common way of measuring tradeoff attacks [<a href="https://eprint.iacr.org/2015/227.pdf">19</a>].</p>
<p>Given the constraints described in the previous chapters, the maximum possible performance ratio between the fast and the light verification modes was empirically determined to be 8. This is because:</p>
<ol type="1">
<li>Further increase of the light verification time would violate the constraints set out in chapter 1.3.</li>
<li>Further decrease of the fast mode runtime would violate the constraints set out in chapter 1.1, in particular the overhead time of program generation and result calculation would become too high.</li>
</ol>
<p>Additionally, 256 MiB was selected as the maximum amount of memory that can be required in the light-client mode. This amount is acceptable even for small single-board computers such as the Raspberry Pi.</p>
<p>To keep a constant memory-time product, the maximum fast-mode memory requirement is: </p><div class="fragment"><div class="line">8 * 256 MiB = 2048 MiB</div></div><!-- fragment --><p> This can be further increased since the light mode requires additional chip area for the SuperscalarHash function (see chapter 3.4 and chapter 6 of the Specification). Assuming a conservative estimate of 0.2 mm<sup>2</sup> per SuperscalarHash core and DRAM density of 0.149 Gb/mm<sup>2</sup> [<a href="http://en.thelec.kr/news/articleView.html?idxno=20">20</a>], the additional memory is:</p>
<div class="fragment"><div class="line">8 * 0.2 * 0.149 * 1024 / 8 = 30.5 MiB</div></div><!-- fragment --><p> or 32 MiB when rounded to the nearest power of 2. The total memory requirement of the fast mode can be 2080 MiB with a roughly constant AT product.</p>
<h2>2. Virtual machine architecture</h2>
<p>This section describes the design of the RandomX virtual machine (VM).</p>
<h3>2.1 Instruction set</h3>
<p>RandomX uses a fixed-length instruction encoding with 8 bytes per instruction. This allows a 32-bit immediate value to be included in the instruction word. The interpretation of the instruction word bits was chosen so that any 8-byte word is a valid instruction. This allows for very efficient random program generation (see chapter 1.1.1).</p>
<h4>2.1.1 Instruction complexity</h4>
<p>The VM is a complex instruction set machine that allows both register and memory addressed operands. However, each RandomX instructions translates to only 1-7 x86 instructions (1.8 on average). It is important to keep the instruction complexity relatively low to minimize the efficiency advantage of specialized hardware with a tailored instruction set.</p>
<h3>2.2 Program</h3>
<p>The program executed by the VM has the form of a loop consisting of 256 random instructions.</p>
<ul>
<li>256 instructions is long enough to provide a large number of possible programs and enough space for branches. The number of different programs that can be generated is limited to 2<sup>512</sup> = 1.3e+154, which is the number of possible seed values of the random generator.</li>
<li>256 instructions is short enough so that high-performance CPUs can execute one iteration in similar time it takes to fetch data from DRAM. This is advantageous because it allows Dataset accesses to be synchronized and fully prefetchable (see chapter 2.9).</li>
<li>Since the program is a loop, it can take advantage of the μop cache [<a href="https://en.wikipedia.org/wiki/CPU_cache#Micro-operation_(%CE%BCop_or_uop)_cache">6</a>] that is present in some x86 CPUs. Running a loop from the μop cache allows the CPU to power down the x86 instruction decoders, which should help to equalize the power efficiency between x86 and architectures with simple instruction decoding.</li>
</ul>
<h3>2.3 Registers</h3>
<p>The VM uses 8 integer registers and 12 floating point registers. This is the maximum that can be allocated as physical registers in x86-64, which has the fewest architectural registers among common 64-bit CPU architectures. Using more registers would put x86 CPUs at a disadvantage since they would have to use memory to store VM register contents.</p>
<h3>2.4 Integer operations</h3>
<p>RandomX uses all primitive integer operations that have high output entropy: addition (IADD_RS, IADD_M), subtraction (ISUB_R, ISUB_M, INEG_R), multiplication (IMUL_R, IMUL_M, IMULH_R, IMULH_M, ISMULH_R, ISMULH_M, IMUL_RCP), exclusive or (IXOR_R, IXOR_M) and rotation (IROR_R, IROL_R).</p>
<h4>2.4.1 IADD_RS</h4>
<p>The IADD_RS instruction utilizes the address calculation logic of CPUs and can be performed in a single hardware instruction by most CPUs (x86 <code>lea</code>, arm <code>add</code>).</p>
<h4>2.4.2 IMUL_RCP</h4>
<p>Because integer division is not fully pipelined in CPUs and can be made faster in ASICs, the IMUL_RCP instruction requires only one division per program to calculate the reciprocal. This forces an ASIC to include a hardware divider without giving them a performance advantage during program execution.</p>
<h4>2.4.3 IROR_R/IROL_R</h4>
<p>Rotation instructions are split between rotate right and rotate left with a 4:1 ratio. Rotate right has a higher frequency because some architecures (like ARM) don't support rotate left natively (it must be emulated using rotate right).</p>
<h4>2.4.4 ISWAP_R</h4>
<p>This instruction can be executed efficiently by CPUs that support register renaming/move elimination.</p>
<h3>2.5 Floating point operations</h3>
<p>RandomX uses double precision floating point operations, which are supported by the majority of CPUs and require more complex hardware than single precision. All operations are performed as 128-bit vector operations, which is also supported by all major CPU architectures.</p>
<p>RandomX uses five operations that are guaranteed by the IEEE 754 standard to give correctly rounded results: addition, subtraction, multiplication, division and square root. All 4 rounding modes defined by the standard are used.</p>
<h4>2.5.1 Floating point register groups</h4>
<p>The domains of floating point operations are separated into "additive" operations, which use register group F and "multiplicative" operations, which use register group E. This is done to prevent addition/subtraction from becoming no-op when a small number is added to a large number. Since the range of the F group registers is limited to around <code>±3.0e+14</code>, adding or subtracting a floating point number with absolute value larger than 1 always changes at least 5 fraction bits.</p>
<p>Because the limited range of group F registers would allow the use of a more efficient fixed-point representation (with 80-bit numbers), the FSCAL instruction manipulates the binary representation of the floating point format to make this optimization more difficult.</p>
<p><a class="el" href="../../d4/d91/structGroup.html">Group</a> E registers are restricted to positive values, which avoids <code>NaN</code> results (such as square root of a negative number or <code>0 * ∞</code>). Division uses only memory source operand to avoid being optimized into multiplication by constant reciprocal. The exponent of group E memory operands is set to a value between -255 and 0 to avoid division and multiplication by 0 and to increase the range of numbers that can be obtained. The approximate range of possible group E register values is <code>1.7E-77</code> to <code>infinity</code>.</p>
<p>Approximate distribution of floating point register values at the end of each program loop is shown in these figures (left - group F, right - group E):</p>
<div class="image">
<img src="https://i.imgur.com/64G4qE8.png" alt="Imgur"/>
</div>
<p>*(Note: bins are marked by the left-side value of the interval, e.g. bin marked <code>1e-40</code> contains values from <code>1e-40</code> to <code>1e-20</code>.)*</p>
<p>The small number of F register values at <code>1e+14</code> is caused by the FSCAL instruction, which significantly increases the range of the register values.</p>
<p><a class="el" href="../../d4/d91/structGroup.html">Group</a> E registers cover a very large range of values. About 2% of programs produce at least one <code>infinity</code> value.</p>
<p>To maximize entropy and also to fit into one 64-byte cache line, floating point registers are combined using the XOR operation at the end of each iteration before being stored into the Scratchpad.</p>
<h3>2.6 Branches</h3>
<p>Modern CPUs invest a lot of die area and energy to handle branches. This includes:</p>
<ul>
<li>Branch predictor unit [<a href="https://en.wikipedia.org/wiki/Branch_predictor">21</a>]</li>
<li>Checkpoint/rollback states that allow the CPU to recover in case of a branch misprediction.</li>
</ul>
<p>To take advantage of speculative designs, the random programs should contain branches. However, if branch prediction fails, the speculatively executed instructions are thrown away, which results in a certain amount of wasted energy with each misprediction. Therefore we should aim to minimize the number of mispredictions.</p>
<p>Additionally, branches in the code are essential because they significantly reduce the amount of static optimizations that can be made. For example, consider the following x86 instruction sequence: </p><div class="fragment"><div class="line">    ...</div><div class="line">branch_target_00:</div><div class="line">    ...</div><div class="line">    xor r8, r9</div><div class="line">    test r10, 2088960</div><div class="line">    je branch_target_00</div><div class="line">    xor r8, r9</div><div class="line">    ...</div></div><!-- fragment --><p> The XOR operations would normally cancel out, but cannot be optimized away due to the branch because the result will be different if the branch is taken. Similarly, the ISWAP_R instruction could be always statically optimized out if it wasn't for branches.</p>
<p>In general, random branches must be designed in such way that:</p>
<ol type="1">
<li>Infinite loops are not possible.</li>
</ol>
<ol type="1">
<li>The number of mispredicted branches is small.</li>
</ol>
<ol type="1">
<li>Branch condition depends on a runtime value to disable static branch optimizations.</li>
</ol>
<h4>2.6.1 Branch prediction</h4>
<p>Unfortunately, we haven't found a way how to utilize branch prediction in RandomX. Because RandomX is a consensus protocol, all the rules must be set out in advance, which includes the rules for branches. Fully predictable branches cannot depend on the runtime value of any VM register (since register values are pseudorandom and unpredictable), so they would have to be static and therefore easily optimizable by specialized hardware.</p>
<h4>2.6.2 CBRANCH instruction</h4>
<p>RandomX therefore uses random branches with a jump probability of 1/256 and branch condition that depends on an integer register value. These branches will be predicted as "not taken" by the CPU. Such branches are "free" in most CPU designs unless they are taken. While this doesn't take advantage of the branch predictors, speculative designs will see a significant performance boost compared to non-speculative branch handling - see Appendix B for more information.</p>
<p>The branching conditions and jump targets are chosen in such way that infinite loops in RandomX code are impossible because the register controlling the branch will never be modified in the repeated code block. Each CBRANCH instruction can jump up to twice in a row. Handling CBRANCH using predicated execution [<a href="https://en.wikipedia.org/wiki/Predication_(computer_architecture)">22</a>] is impractical because the branch is not taken most of the time.</p>
<h3>2.7 Instruction-level parallelism</h3>
<p>CPUs improve their performance using several techniques that utilize instruction-level parallelism of the executed code. These techniques include:</p>
<ul>
<li>Having multiple execution units that can execute operations in parallel (<em>superscalar execution</em>).</li>
<li>Executing instruction not in program order, but in the order of operand availability (<em>out-of-order execution</em>).</li>
<li>Predicting which way branches will go to enhance the benefits of both superscalar and out-of-order execution.</li>
</ul>
<p>RandomX benefits from all these optimizations. See Appendix B for a detailed analysis.</p>
<h3>2.8 Scratchpad</h3>
<p>The Scratchpad is used as read-write memory. Its size was selected to fit entirely into CPU cache.</p>
<h4>2.8.1 Scratchpad levels</h4>
<p>The Scratchpad is split into 3 levels to mimic the typical CPU cache hierarchy [<a href="https://en.wikipedia.org/wiki/CPU_cache">23</a>]. Most VM instructions access "L1" and "L2" Scratchpad because L1 and L2 CPU caches are located close to the CPU execution units and provide the best random access latency. The ratio of reads from L1 and L2 is 3:1, which matches the inverse ratio of typical latencies (see table below).</p>
<table class="doxtable">
<tr>
<th>CPU μ-architecture</th><th>L1 latency</th><th>L2 latency</th><th>L3 latency</th><th>source  </th></tr>
<tr>
<td>ARM Cortex A55</td><td>2</td><td>6</td><td>-</td><td>[<a href="https://www.anandtech.com/show/11441/dynamiq-and-arms-new-cpus-cortex-a75-a55/4">24</a>] </td></tr>
<tr>
<td>AMD Zen+</td><td>4</td><td>12</td><td>40</td><td>[<a href="https://en.wikichip.org/wiki/amd/microarchitectures/zen%2B#Memory_Hierarchy">25</a>] </td></tr>
<tr>
<td>Intel Skylake</td><td>4</td><td>12</td><td>42</td><td>[<a href="https://en.wikichip.org/wiki/intel/microarchitectures/skylake_(client)#Memory_Hierarchy">26</a>] </td></tr>
</table>
<p>The L3 cache is much larger and located further from the CPU core. As a result, its access latencies are much higher and can cause stalls in program execution.</p>
<p>RandomX therefore performs only 2 random accesses into "L3" Scratchpad per program iteration (steps 2 and 3 in chapter 4.6.2 of the Specification). Register values from a given iteration are written into the same locations they were loaded from, which guarantees that the required cache lines have been moved into the faster L1 or L2 caches.</p>
<p>Additionally, integer instructions that read from a fixed address also use the whole "L3" Scratchpad (Table 5.1.4 of the Specification) because repetitive accesses will ensure that the cache line will be placed in the L1 cache of the CPU. This shows that the Scratchpad level doesn't always directly correspond to the same CPU cache level.</p>
<h4>2.8.2 Scratchpad writes</h4>
<p>There are two ways the Scratchpad is modified during VM execution:</p>
<ol type="1">
<li>At the end of each program iteration, all register values are written into "L3" Scratchpad (see Specification chapter 4.6.2, steps 9 and 11). This writes a total of 128 bytes per iteration in two 64-byte blocks.</li>
<li>The ISTORE instruction does explicit stores. On average, there are 16 stores per program, out of which 2 stores are into the "L3" level. Each ISTORE instruction writes 8 bytes.</li>
</ol>
<p>The image below shows an example of the distribution of writes to the Scratchpad. Each pixel in the image represents 8 bytes of the Scratchpad. Red pixels represent portions of the Scratchpad that have been overwritten at least once during hash calculation. The "L1" and "L2" levels are on the left side (almost completely overwritten). The right side of the scratchpad represents the bottom 1792 KiB. Only about 66% of it are overwritten, but the writes are spread uniformly and randomly.</p>
<div class="image">
<img src="https://i.imgur.com/pRz6aBG.png" alt="Imgur"/>
</div>
<p>See Appendix D for the analysis of Scratchpad entropy.</p>
<h4>2.8.3 Read-write ratio</h4>
<p>Programs make, on average, 39 reads (instructions IADD_M, ISUB_M, IMUL_M, IMULH_M, ISMULH_M, IXOR_M, FADD_M, FSUB_M, FDIV_M) and 16 writes (instruction ISTORE) to the Scratchpad per program iteration. Additional 128 bytes are read and written implicitly to initialize and store register values. 64 bytes of data is read from the Dataset per iteration. In total:</p>
<ul>
<li>The average amount of data read from memory per program iteration is: 39 * 8 + 128 + 64 = <b>504 bytes</b>.</li>
<li>The average mount of data written to memory per program iteration is: 16 * 8 + 128 = <b>256 bytes</b>.</li>
</ul>
<p>This is close to a 2:1 read/write ratio, which CPUs are optimized for.</p>
<h3>2.9 Dataset</h3>
<p>Since the Scratchpad is usually stored in the CPU cache, only Dataset accesses utilize the memory controllers.</p>
<p>RandomX randomly reads from the Dataset once per program iteration (16384 times per hash result). Since the Dataset must be stored in DRAM, it provides a natural parallelization limit, because DRAM cannot do more than about 25 million random accesses per second per bank group. Each separately addressable bank group allows a throughput of around 1500 H/s.</p>
<p>All Dataset accesses read one CPU cache line (64 bytes) and are fully prefetched. The time to execute one program iteration described in chapter 4.6.2 of the Specification is about the same as typical DRAM access latency (50-100 ns).</p>
<h4>2.9.1 Cache</h4>
<p>The Cache, which is used for light verification and Dataset construction, is about 8 times smaller than the Dataset. To keep a constant area-time product, each Dataset item is constructed from 8 random Cache accesses.</p>
<p>Because 256 MiB is small enough to be included on-chip, RandomX uses a custom high-latency, high-power mixing function ("SuperscalarHash") which defeats the benefits of using low-latency memory and the energy required to calculate SuperscalarHash makes light mode very inefficient for mining (see chapter 3.4).</p>
<p>Using less than 256 MiB of memory is not possible due to the use of tradeoff-resistant Argon2d with 3 iterations. When using 3 iterations (passes), halving the memory usage increases computational cost 3423 times for the best tradeoff attack [<a href="https://eprint.iacr.org/2015/430.pdf">27</a>].</p>
<h2>3. Custom functions</h2>
<h3>3.1 AesGenerator1R</h3>
<p>AesGenerator1R was designed for the fastest possible generation of pseudorandom data to fill the Scratchpad. It takes advantage of hardware accelerated AES in modern CPUs. Only one AES round is performed per 16 bytes of output, which results in throughput exceeding 20 GB/s in most modern CPUs.</p>
<p>AesGenerator1R gives a good output distribution provided that it's initialized with a sufficiently 'random' initial state (see Appendix F).</p>
<h3>3.2 AesGenerator4R</h3>
<p>AesGenerator4R uses 4 AES rounds to generate pseudorandom data for Program Buffer initialization. Since 2 AES rounds are sufficient for full avalanche of all input bits [<a href="https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf">28</a>], AesGenerator4R has excellent statistical properties (see Appendix F) while maintaining very good performance.</p>
<p>The reversible nature of this generator is not an issue since the generator state is always initialized using the output of a non-reversible hashing function (Blake2b).</p>
<h3>3.3 AesHash1R</h3>
<p>AesHash was designed for the fastest possible calculation of the Scratchpad fingerprint. It interprets the Scratchpad as a set of AES round keys, so it's equivalent to AES encryption with 32768 rounds. Two extra rounds are performed at the end to ensure avalanche of all Scratchpad bits in each lane.</p>
<p>The reversible nature of AesHash1R is not a problem for two main reasons:</p>
<ul>
<li>It is not possible to directly control the input of AesHash1R.</li>
<li>The output of AesHash1R is passed into the Blake2b hashing function, which is not reversible.</li>
</ul>
<h3>3.4 SuperscalarHash</h3>
<p>SuperscalarHash was designed to burn as much power as possible while the CPU is waiting for data to be loaded from DRAM. The target latency of 170 cycles corresponds to the usual DRAM latency of 40-80 ns and clock frequency of 2-4 GHz. ASIC devices designed for light-mode mining with low-latency memory will be bottlenecked by SuperscalarHash when calculating Dataset items and their efficiency will be destroyed by the high power usage of SuperscalarHash.</p>
<p>The average SuperscalarHash function contains a total of 450 instructions, out of which 155 are 64-bit multiplications. On average, the longest dependency chain is 95 instructions long. An ASIC design for light-mode mining, with 256 MiB of on-die memory and 1-cycle latency for all operations, will need on average 95 * 8 = 760 cycles to construct a Dataset item, assuming unlimited parallelization. It will have to execute 155 * 8 = 1240 64-bit multiplications per item, which will consume energy comparable to loading 64 bytes from DRAM.</p>
<h2>Appendix</h2>
<h3>A. The effect of chaining VM executions</h3>
<p>Chapter 1.2 describes why <code>N</code> random programs are chained to prevent mining strategies that search for 'easy' programs. RandomX uses a value of <code>N = 8</code>.</p>
<p>Let's define <code>Q</code> as the ratio of acceptable programs in a strategy that uses filtering. For example <code>Q = 0.75</code> means that 25% of programs are rejected.</p>
<p>For <code>N = 1</code>, there are no wasted program executions and the only cost is program generation and the filtering itself. The calculations below assume that these costs are zero and the only real cost is program execution. However, this is a simplification because program generation in RandomX is not free (the first program generation requires full Scratchpad initialization), but it describes a best-case scenario for an attacker.</p>
<p>For <code>N &gt; 1</code>, the first program can be filtered as usual, but after the program is executed, there is a chance of <code>1-Q</code> that the next program should be rejected and we have wasted one program execution.</p>
<p>For <code>N</code> chained executions, the chance is only <code>Q<sup>N</sup></code> that all programs in the chain are acceptable. However, during each attempt to find such chain, we will waste the execution of some programs. For <code>N = 8</code>, the number of wasted programs per attempt is equal to <code>(1-Q)*(1+2*Q+3*Q<sup>2</sup>+4*Q<sup>3</sup>+5*Q<sup>4</sup>+6*Q<sup>5</sup>+7*Q<sup>6</sup>)</code> (approximately 2.5 for <code>Q = 0.75</code>).</p>
<p>Let's consider 3 mining strategies:</p>
<h4>Strategy I</h4>
<p>Honest miner that doesn't reject any programs (<code>Q = 1</code>).</p>
<h4>Strategy II</h4>
<p>Miner that uses optimized custom hardware that cannot execute 25% of programs (<code>Q = 0.75</code>), but supported programs can be executed 50% faster.</p>
<h4>Strategy III</h4>
<p>Miner that can execute all programs, but rejects 25% of the slowest programs for the first program in the chain. This gives a 5% performance boost for the first program in the chain (this matches the runtime distribution from Appendix C).</p>
<h4>Results</h4>
<p>The table below lists the results for the above 3 strategies and different values of <code>N</code>. The columns <b>N(I)</b>, <b>N(II)</b> and <b>N(III)</b> list the number of programs that each strategy has to execute on average to get one valid hash result (this includes programs wasted in rejected chains). Columns <b>Speed(I)</b>, <b>Speed(II)</b> and <b>Speed(III)</b> list the average mining performance relative to strategy I.</p>
<table class="doxtable">
<tr>
<th>N</th><th>N(I)</th><th>N(II)</th><th>N(III)</th><th>Speed(I)</th><th>Speed(II)</th><th>Speed(III)  </th></tr>
<tr>
<td>1</td><td>1</td><td>1</td><td>1</td><td>1.00</td><td>1.50</td><td>1.05 </td></tr>
<tr>
<td>2</td><td>2</td><td>2.3</td><td>2</td><td>1.00</td><td>1.28</td><td>1.02 </td></tr>
<tr>
<td>4</td><td>4</td><td>6.5</td><td>4</td><td>1.00</td><td>0.92</td><td>1.01 </td></tr>
<tr>
<td>8</td><td>8</td><td>27.0</td><td>8</td><td>1.00</td><td>0.44</td><td>1.00 </td></tr>
</table>
<p>For <code>N = 8</code>, strategy II will perform at less than half the speed of the honest miner despite having a 50% performance advantage for selected programs. The small statistical advantage of strategy III is negligible with <code>N = 8</code>.</p>
<h3>B. Performance simulation</h3>
<p>As discussed in chapter 2.7, RandomX aims to take advantage of the complex design of modern high-performance CPUs. To evaluate the impact of superscalar, out-of-order and speculative execution, we performed a simplified CPU simulation. Source code is available in <a href="../../../src/tests/perf-simulation.cpp">perf-simulation.cpp</a>.</p>
<h4>CPU model</h4>
<p>The model CPU uses a 3-stage pipeline to achieve an ideal throughput of 1 instruction per cycle: </p><div class="fragment"><div class="line">        (1)                        (2)                     (3)</div><div class="line">+------------------+       +----------------+      +----------------+</div><div class="line">|   Instruction    |       |                |      |                |</div><div class="line">|      fetch       | ---&gt;  | Memory access  | ---&gt; |    Execute     |</div><div class="line">|    + decode      |       |                |      |                |</div><div class="line">+------------------+       +----------------+      +----------------+</div></div><!-- fragment --><p> The 3 stages are:</p>
<ol type="1">
<li>Instruction fetch and decode. This stage loads the instruction from the Program Buffer and decodes the instruction operation and operands.</li>
<li>Memory access. If this instruction uses a memory operand, it is loaded from the Scratchpad in this stage. This includes the calculation of the memory address. Stores are also performed in this stage. The value of the address register must be available in this stage.</li>
<li>Execute. This stage executes the instruction using the operands retrieved in the previous stages and writes the results into the register file.</li>
</ol>
<p>Note that this is an optimistically short pipeline that would not allow very high clock speeds. Designs using a longer pipeline would significantly increase the benefits of speculative execution.</p>
<h4>Superscalar execution</h4>
<p>Our model CPU contains two kinds of components:</p>
<ul>
<li>Execution unit (EXU) - it is used to perform the actual integer or floating point operation. All RandomX instructions except ISTORE must use an execution unit in the 3rd pipeline stage. All operations are considered to take only 1 clock cycle.</li>
<li>Memory unit (MEM) - it is used for loads and stores into Scratchpad. All memory instructions (including ISTORE) use a memory unit in the 2nd pipeline stage.</li>
</ul>
<p>A superscalar design will contain multiple execution or memory units to improve performance.</p>
<h4>Out-of-order execution</h4>
<p>The simulation model supports two designs:</p>
<ol type="1">
<li><b>In-order</b> - all instructions are executed in the order they appear in the Program Buffer. This design will stall if a dependency is encountered or the required EXU/MEM unit is not available.</li>
<li><b>Out-of-order</b> - doesn't execute instructions in program order, but an instruction can be executed when its operands are ready and the required EXU/MEM units are available.</li>
</ol>
<h4>Branch handling</h4>
<p>The simulation model supports two types of branch handling:</p>
<ol type="1">
<li><b>Non-speculative</b> - when a branch is encountered, the pipeline is stalled. This typically adds a 3-cycle penalty for each branch.</li>
<li><b>Speculative</b> - all branches are predicted not taken and the pipeline is flushed if a misprediction occurs (probability of 1/256).</li>
</ol>
<h4>Results</h4>
<p>The following 10 designs were simulated and the average number of clock cycles to execute a RandomX program (256 instructions) was measured.</p>
<table class="doxtable">
<tr>
<th>design</th><th>superscalar config.</th><th>reordering</th><th>branch handling</th><th>execution time [cycles]</th><th>IPC  </th></tr>
<tr>
<td>#1</td><td>1 EXU + 1 MEM</td><td>in-order</td><td>non-speculative</td><td>293</td><td>0.87 </td></tr>
<tr>
<td>#2</td><td>1 EXU + 1 MEM</td><td>in-order</td><td>speculative</td><td>262</td><td>0.98 </td></tr>
<tr>
<td>#3</td><td>2 EXU + 1 MEM</td><td>in-order</td><td>non-speculative</td><td>197</td><td>1.3 </td></tr>
<tr>
<td>#4</td><td>2 EXU + 1 MEM</td><td>in-order</td><td>speculative</td><td>161</td><td>1.6 </td></tr>
<tr>
<td>#5</td><td>2 EXU + 1 MEM</td><td>out-of-order</td><td>non-speculative</td><td>144</td><td>1.8 </td></tr>
<tr>
<td>#6</td><td>2 EXU + 1 MEM</td><td>out-of-order</td><td>speculative</td><td>122</td><td>2.1 </td></tr>
<tr>
<td>#7</td><td>4 EXU + 2 MEM</td><td>in-order</td><td>non-speculative</td><td>135</td><td>1.9 </td></tr>
<tr>
<td>#8</td><td>4 EXU + 2 MEM</td><td>in-order</td><td>speculative</td><td>99</td><td>2.6 </td></tr>
<tr>
<td>#9</td><td>4 EXU + 2 MEM</td><td>out-of-order</td><td>non-speculative</td><td>89</td><td>2.9 </td></tr>
<tr>
<td>#10</td><td>4 EXU + 2 MEM</td><td>out-of-order</td><td>speculative</td><td>64</td><td>4.0 </td></tr>
</table>
<p>The benefits of superscalar, out-of-order and speculative designs are clearly demonstrated.</p>
<h3>C. RandomX runtime distribution</h3>
<p>Runtime numbers were measured on AMD Ryzen 7 1700 running at 3.0 GHz using 1 core. Source code to measure program execution and verification times is available in <a href="../../../src/tests/runtime-distr.cpp">runtime-distr.cpp</a>. Source code to measure the performance of the x86 JIT compiler is available in <a href="../../../src/tests/jit-performance.cpp">jit-performance.cpp</a>.</p>
<h4>Fast mode - program execution</h4>
<p>The following figure shows the distribution of the runtimes of a single VM program (in fast mode). This includes: program generation, JIT compilation, VM execution and Blake2b hash of the register file. Program generation and JIT compilation was measured to take 3.6 μs per program.</p>
<div class="image">
<img src="https://i.imgur.com/ikv2z2i.png" alt="Imgur"/>
</div>
<p>AMD Ryzen 7 1700 can calculate 625 hashes per second in fast mode (using 1 thread), which means a single hash result takes 1600 μs (1.6 ms). This consists of (approximately):</p>
<ul>
<li>1480 μs for VM execution (8 programs)</li>
<li>45 μs for initial Scratchpad fill (AesGenerator1R).</li>
<li>45 μs for final Scratchpad hash (AesHash1R).</li>
<li>30 μs for program generation and JIT compilation (8 programs)</li>
</ul>
<p>This gives a total overhead of 7.5% (time per hash spent not executing VM).</p>
<h4>Light mode - verification time</h4>
<p>The following figure shows the distribution of times to calculate 1 hash result using the light mode. Most of the time is spent executing SuperscalarHash to calculate Dataset items (13.2 ms out of 14.8 ms). The average verification time exactly matches the performance of the CryptoNight algorithm.</p>
<div class="image">
<img src="https://i.imgur.com/VtwwJT8.png" alt="Imgur"/>
</div>
<h3>D. Scratchpad entropy analysis</h3>
<p>The average entropy of the Scratchpad after 8 program executions was approximated using the LZMA compression algorithm:</p>
<ol type="1">
<li>Hash resuls were calculated and the final scratchpads were written to disk as files with '.spad' extension (source code: <a href="../../../src/tests/scratchpad-entropy.cpp">scratchpad-entropy.cpp</a>)</li>
<li>The files were compressed using 7-Zip [<a href="https://www.7-zip.org/">29</a>] in Ultra compression mode: <code>7z.exe a -t7z -m0=lzma2 -mx=9 scratchpads.7z *.spad</code></li>
</ol>
<p>The size of the resulting archive is approximately 99.98% of the uncompressed size of the scratchpad files. This shows that the Scratchpad retains high entropy during VM execution.</p>
<h3>E. SuperscalarHash analysis</h3>
<p>SuperscalarHash is a custom function used by RandomX to generate Dataset items. It operates on 8 integer registers and uses a random sequence of instructions. About 1/3 of the instructions are multiplications.</p>
<p>The following figure shows the sensitivity of SuperscalarHash to changing a single bit of an input register:</p>
<div class="image">
<img src="https://i.imgur.com/ztZ0V0G.png" alt="Imgur"/>
</div>
<p>This shows that SuperscalaHash has quite low sensitivity to high-order bits and somewhat decreased sensitivity to the lowest-order bits. Sensitivity is highest for bits 3-53 (inclusive).</p>
<p>When calculating a Dataset item, the input of the first SuperscalarHash depends only on the item number. To ensure a good distribution of results, the constants described in section 7.3 of the Specification were chosen to provide unique values of bits 3-53 for <em>all</em> item numbers in the range 0-34078718 (the Dataset contains 34078719 items). All initial register values for all Dataset item numbers were checked to make sure bits 3-53 of each register are unique and there are no collisions (source code: <a href="../../../src/tests/superscalar-init.cpp">superscalar-init.cpp</a>). While this is not strictly necessary to get unique output from SuperscalarHash, it's a security precaution that mitigates the non-perfect avalanche properties of the randomly generated SuperscalarHash instances.</p>
<h3>F. Statistical tests of RNG</h3>
<p>Both AesGenerator1R and AesGenerator4R were tested using the TestU01 library [<a href="http://simul.iro.umontreal.ca/testu01/tu01.html">30</a>] intended for empirical testing of random number generators. The source code is available in <a href="../../../src/tests/rng-tests.cpp">rng-tests.cpp</a>.</p>
<p>The tests sample about 200 MB ("SmallCrush" test), 500 GB ("Crush" test) or 4 TB ("BigCrush" test) of output from each generator. This is considerably more than the amounts generated in RandomX (2176 bytes for AesGenerator4R and 2 MiB for AesGenerator1R), so failures in the tests don't necessarily imply that the generators are not suitable for their use case.</p>
<h4>AesGenerator4R</h4>
<p>The generator passes all tests in the "BigCrush" suite when initialized using the Blake2b hash function:</p>
<div class="fragment"><div class="line">$ bin/rng-tests 1</div><div class="line">state0 = 67e8bbe567a1c18c91a316faf19fab73</div><div class="line">state1 = 39f7c0e0a8d96512c525852124fdc9fe</div><div class="line">state2 = 7abb07b2c90e04f098261e323eee8159</div><div class="line">state3 = 3df534c34cdfbb4e70f8c0e1826f4cf7</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">========= Summary results of BigCrush =========</div><div class="line"></div><div class="line"> Version:          TestU01 1.2.3</div><div class="line"> Generator:        AesGenerator4R</div><div class="line"> Number of statistics:  160</div><div class="line"> Total CPU time:   02:50:18.34</div><div class="line"></div><div class="line"> All tests were passed</div></div><!-- fragment --><p>The generator passes all tests in the "Crush" suite even with an initial state set to all zeroes. </p><div class="fragment"><div class="line">$ bin/rng-tests 0</div><div class="line">state0 = 00000000000000000000000000000000</div><div class="line">state1 = 00000000000000000000000000000000</div><div class="line">state2 = 00000000000000000000000000000000</div><div class="line">state3 = 00000000000000000000000000000000</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">========= Summary results of Crush =========</div><div class="line"></div><div class="line"> Version:          TestU01 1.2.3</div><div class="line"> Generator:        AesGenerator4R</div><div class="line"> Number of statistics:  144</div><div class="line"> Total CPU time:   00:25:17.95</div><div class="line"></div><div class="line"> All tests were passed</div></div><!-- fragment --><h4>AesGenerator1R</h4>
<p>The generator passes all tests in the "Crush" suite when initialized using the Blake2b hash function.</p>
<div class="fragment"><div class="line">$ bin/rng-tests 1</div><div class="line">state0 = 67e8bbe567a1c18c91a316faf19fab73</div><div class="line">state1 = 39f7c0e0a8d96512c525852124fdc9fe</div><div class="line">state2 = 7abb07b2c90e04f098261e323eee8159</div><div class="line">state3 = 3df534c34cdfbb4e70f8c0e1826f4cf7</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">========= Summary results of Crush =========</div><div class="line"></div><div class="line"> Version:          TestU01 1.2.3</div><div class="line"> Generator:        AesGenerator1R</div><div class="line"> Number of statistics:  144</div><div class="line"> Total CPU time:   00:25:06.07</div><div class="line"></div><div class="line"> All tests were passed</div></div><!-- fragment --><p>When the initial state is initialized to all zeroes, the generator fails 1 test out of 144 tests in the "Crush" suite:</p>
<div class="fragment"><div class="line">$ bin/rng-tests 0</div><div class="line">state0 = 00000000000000000000000000000000</div><div class="line">state1 = 00000000000000000000000000000000</div><div class="line">state2 = 00000000000000000000000000000000</div><div class="line">state3 = 00000000000000000000000000000000</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">========= Summary results of Crush =========</div><div class="line"></div><div class="line"> Version:          TestU01 1.2.3</div><div class="line"> Generator:        AesGenerator1R</div><div class="line"> Number of statistics:  144</div><div class="line"> Total CPU time:   00:26:12.75</div><div class="line"> The following tests gave p-values outside [0.001, 0.9990]:</div><div class="line"> (eps  means a value &lt; 1.0e-300):</div><div class="line"> (eps1 means a value &lt; 1.0e-15):</div><div class="line"></div><div class="line">       Test                          p-value</div><div class="line"> ----------------------------------------------</div><div class="line"> 12  BirthdaySpacings, t = 3        1 -  4.4e-5</div><div class="line"> ----------------------------------------------</div><div class="line"> All other tests were passed</div></div><!-- fragment --><h2>References</h2>
<p>[1] CryptoNote whitepaper - <a href="https://cryptonote.org/whitepaper.pdf">https://cryptonote.org/whitepaper.pdf</a></p>
<p>[2] ProgPoW: Inefficient integer multiplications - <a href="https://github.com/ifdefelse/ProgPOW/issues/16">https://github.com/ifdefelse/ProgPOW/issues/16</a></p>
<p>[3] Cryptographic Hashing function - <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">https://en.wikipedia.org/wiki/Cryptographic_hash_function</a></p>
<p>[4] randprog - <a href="https://github.com/hyc/randprog">https://github.com/hyc/randprog</a></p>
<p>[5] RandomJS - <a href="https://github.com/tevador/RandomJS">https://github.com/tevador/RandomJS</a></p>
<p>[6] μop cache - <a href="https://en.wikipedia.org/wiki/CPU_cache#Micro-operation_(%CE%BCop_or_uop)_cache">https://en.wikipedia.org/wiki/CPU_cache#Micro-operation_(%CE%BCop_or_uop)_cache</a></p>
<p>[7] Instruction-level parallelism - <a href="https://en.wikipedia.org/wiki/Instruction-level_parallelism">https://en.wikipedia.org/wiki/Instruction-level_parallelism</a></p>
<p>[8] Superscalar processor - <a href="https://en.wikipedia.org/wiki/Superscalar_processor">https://en.wikipedia.org/wiki/Superscalar_processor</a></p>
<p>[9] Out-of-order execution - <a href="https://en.wikipedia.org/wiki/Out-of-order_execution">https://en.wikipedia.org/wiki/Out-of-order_execution</a></p>
<p>[10] Speculative execution - <a href="https://en.wikipedia.org/wiki/Speculative_execution">https://en.wikipedia.org/wiki/Speculative_execution</a></p>
<p>[11] Register renaming - <a href="https://en.wikipedia.org/wiki/Register_renaming">https://en.wikipedia.org/wiki/Register_renaming</a></p>
<p>[12] Blake2 hashing function - <a href="https://blake2.net/">https://blake2.net/</a></p>
<p>[13] Advanced Encryption Standard - <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">https://en.wikipedia.org/wiki/Advanced_Encryption_Standard</a></p>
<p>[14] Log-normal distribution - <a href="https://en.wikipedia.org/wiki/Log-normal_distribution">https://en.wikipedia.org/wiki/Log-normal_distribution</a></p>
<p>[15] CryptoNight hash function - <a href="https://cryptonote.org/cns/cns008.txt">https://cryptonote.org/cns/cns008.txt</a></p>
<p>[16] Dynamic random-access memory - <a href="https://en.wikipedia.org/wiki/Dynamic_random-access_memory">https://en.wikipedia.org/wiki/Dynamic_random-access_memory</a></p>
<p>[17] Multi-channel memory architecture - <a href="https://en.wikipedia.org/wiki/Multi-channel_memory_architecture">https://en.wikipedia.org/wiki/Multi-channel_memory_architecture</a></p>
<p>[18] Obelisk GRN1 chip details - <a href="https://www.grin-forum.org/t/obelisk-grn1-chip-details/4571">https://www.grin-forum.org/t/obelisk-grn1-chip-details/4571</a></p>
<p>[19] Biryukov et al.: Tradeoff Cryptanalysis of Memory-Hard Functions - <a href="https://eprint.iacr.org/2015/227.pdf">https://eprint.iacr.org/2015/227.pdf</a></p>
<p>[20] SK Hynix 20nm DRAM density - <a href="http://en.thelec.kr/news/articleView.html?idxno=20">http://en.thelec.kr/news/articleView.html?idxno=20</a></p>
<p>[21] Branch predictor - <a href="https://en.wikipedia.org/wiki/Branch_predictor">https://en.wikipedia.org/wiki/Branch_predictor</a></p>
<p>[22] Predication - <a href="https://en.wikipedia.org/wiki/Predication_(computer_architecture)">https://en.wikipedia.org/wiki/Predication_(computer_architecture)</a></p>
<p>[23] CPU cache - <a href="https://en.wikipedia.org/wiki/CPU_cache">https://en.wikipedia.org/wiki/CPU_cache</a></p>
<p>[24] Cortex-A55 Microarchitecture - <a href="https://www.anandtech.com/show/11441/dynamiq-and-arms-new-cpus-cortex-a75-a55/4">https://www.anandtech.com/show/11441/dynamiq-and-arms-new-cpus-cortex-a75-a55/4</a></p>
<p>[25] AMD Zen+ Microarchitecture - <a href="https://en.wikichip.org/wiki/amd/microarchitectures/zen%2B#Memory_Hierarchy">https://en.wikichip.org/wiki/amd/microarchitectures/zen%2B#Memory_Hierarchy</a></p>
<p>[26] Intel Skylake Microarchitecture - <a href="https://en.wikichip.org/wiki/intel/microarchitectures/skylake_(client)#Memory_Hierarchy">https://en.wikichip.org/wiki/intel/microarchitectures/skylake_(client)#Memory_Hierarchy</a></p>
<p>[27] Biryukov et al.: Fast and Tradeoff-Resilient Memory-Hard Functions for Cryptocurrencies and Password Hashing - <a href="https://eprint.iacr.org/2015/430.pdf">https://eprint.iacr.org/2015/430.pdf</a> Table 2, page 8</p>
<p>[28] J. Daemen, V. Rijmen: AES Proposal: Rijndael - <a href="https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf">https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf</a> page 28</p>
<p>[29] 7-Zip File archiver - <a href="https://www.7-zip.org/">https://www.7-zip.org/</a></p>
<p>[30] TestU01 library - <a href="http://simul.iro.umontreal.ca/testu01/tu01.html">http://simul.iro.umontreal.ca/testu01/tu01.html</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 2 2023 19:23:33 for Monero by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
