<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Monero: 流</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Monero
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">流 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>在 RapidJSON 中，<code><a class="el" href="../../dc/dc3/classrapidjson_1_1Stream.html" title="Concept for reading and writing characters. ">rapidjson::Stream</a></code> 是用於读写 JSON 的概念（概念是指 C++ 的 concept）。在这里我们先介绍如何使用 RapidJSON 提供的各种流。然后再看看如何自行定义流。</p>
<h1><a class="anchor" id="MemoryStreams"></a>
Memory Streams</h1>
<p>内存流把 JSON 存储在内存之中。</p>
<h2><a class="anchor" id="StringStream"></a>
StringStream (Input)</h2>
<p><code>StringStream</code> 是最基本的输入流，它表示一个完整的、只读的、存储于内存的 JSON。它在 <code>rapidjson/rapidjson.h</code> 中定义。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../db/df5/document_8h.html">rapidjson/document.h</a>&quot;</span> <span class="comment">// 会包含 &quot;rapidjson/rapidjson.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/dc3/namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> json[] = <span class="stringliteral">&quot;[1, 2, 3, 4]&quot;</span>;</div><div class="line"><a class="code" href="../../d2/d8a/structGenericStringStream.html">StringStream</a> <a class="code" href="../../de/dc6/minissdp_8c.html#ab87f55bd0280d90925050a4188c14ab5">s</a>(json);</div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;</div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>(s);</div></div><!-- fragment --><p>由于这是非常常用的用法，RapidJSON 提供 <code>Document::Parse(const char*)</code> 去做完全相同的事情：</p>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> json[] = <span class="stringliteral">&quot;[1, 2, 3, 4]&quot;</span>;</div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;</div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#aadee36db7064cc9894a75c848831cdae">Parse</a>(json);</div></div><!-- fragment --><p>需要注意，<code>StringStream</code> 是 <code><a class="el" href="../../d2/d8a/structGenericStringStream.html" title="Read-only string stream. ">GenericStringStream</a>&lt;<a class="el" href="../../dd/dd8/structUTF8.html" title="UTF-8 encoding. ">UTF8</a>&lt;&gt; &gt;</code> 的 typedef，使用者可用其他编码类去代表流所使用的字符集。</p>
<h2><a class="anchor" id="StringBuffer"></a>
StringBuffer (Output)</h2>
<p><code>StringBuffer</code> 是一个简单的输出流。它分配一个内存缓冲区，供写入整个 JSON。可使用 <code>GetString()</code> 来获取该缓冲区。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d7/dde/stringbuffer_8h.html">rapidjson/stringbuffer.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d9/d53/writer_8h.html">rapidjson/writer.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="../../d7/d69/classGenericStringBuffer.html">StringBuffer</a> <a class="code" href="../../d5/df9/byte__slice_8cpp.html#a59965c4f502e11ebf0b78cb2e8031fdd">buffer</a>;</div><div class="line"><a class="code" href="../../d0/d88/classWriter.html">Writer&lt;StringBuffer&gt;</a> writer(buffer);</div><div class="line">d.Accept(writer);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* output = buffer.<a class="code" href="../../d7/d69/classGenericStringBuffer.html#ab06b8c5f1385bd3dfd4caea8b7510f0b">GetString</a>();</div></div><!-- fragment --><p>当缓冲区满溢，它将自动增加容量。缺省容量是 256 个字符（UTF8 是 256 字节，UTF16 是 512 字节等）。使用者能自行提供分配器及初始容量。</p>
<div class="fragment"><div class="line"><a class="code" href="../../d7/d69/classGenericStringBuffer.html">StringBuffer</a> <a class="code" href="../../db/da7/namespacerandomx.html#a45c7644dc7dd15cc83bfd4e1c2a35c31">buffer1</a>(0, 1024); <span class="comment">// 使用它的分配器，初始大小 = 1024</span></div><div class="line"><a class="code" href="../../d7/d69/classGenericStringBuffer.html">StringBuffer</a> <a class="code" href="../../db/da7/namespacerandomx.html#aef3319eddf0782c9fcb47dde6c99b6fa">buffer2</a>(allocator, 1024);</div></div><!-- fragment --><p>如无设置分配器，<code>StringBuffer</code> 会自行实例化一个内部分配器。</p>
<p>相似地，<code>StringBuffer</code> 是 <code><a class="el" href="../../d7/d69/classGenericStringBuffer.html" title="Represents an in-memory output stream. ">GenericStringBuffer</a>&lt;<a class="el" href="../../dd/dd8/structUTF8.html" title="UTF-8 encoding. ">UTF8</a>&lt;&gt; &gt;</code> 的 typedef。</p>
<h1><a class="anchor" id="FileStreams"></a>
File Streams</h1>
<p>当要从文件解析一个 JSON，你可以把整个 JSON 读入内存并使用上述的 <code>StringStream</code>。</p>
<p>然而，若 JSON 很大，或是内存有限，你可以改用 <code><a class="el" href="../../da/da5/classFileReadStream.html" title="File byte stream for input using fread(). ">FileReadStream</a></code>。它只会从文件读取一部分至缓冲区，然后让那部分被解析。若缓冲区的字符都被读完，它会再从文件读取下一部分。</p>
<h2><a class="anchor" id="FileReadStream"></a>
FileReadStream (Input)</h2>
<p><code><a class="el" href="../../da/da5/classFileReadStream.html" title="File byte stream for input using fread(). ">FileReadStream</a></code> 通过 <code>FILE</code> 指针读取文件。使用者需要提供一个缓冲区。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d1/d0d/filereadstream_8h.html">rapidjson/filereadstream.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/dc3/namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;big.json&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>); <span class="comment">// 非 Windows 平台使用 &quot;r&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> readBuffer[65536];</div><div class="line"><a class="code" href="../../da/da5/classFileReadStream.html">FileReadStream</a> is(fp, readBuffer, <span class="keyword">sizeof</span>(readBuffer));</div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;</div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>(is);</div><div class="line"></div><div class="line">fclose(fp);</div></div><!-- fragment --><p>与 <code>StringStreams</code> 不一样，<code><a class="el" href="../../da/da5/classFileReadStream.html" title="File byte stream for input using fread(). ">FileReadStream</a></code> 是一个字节流。它不处理编码。若文件并非 UTF-8 编码，可以把字节流用 <code><a class="el" href="../../de/d19/classEncodedInputStream.html" title="Input byte stream wrapper with a statically bound encoding. ">EncodedInputStream</a></code> 包装。我们很快会讨论这个问题。</p>
<p>除了读取文件，使用者也可以使用 <code><a class="el" href="../../da/da5/classFileReadStream.html" title="File byte stream for input using fread(). ">FileReadStream</a></code> 来读取 <code>stdin</code>。</p>
<h2><a class="anchor" id="FileWriteStream"></a>
FileWriteStream (Output)</h2>
<p><code><a class="el" href="../../db/d85/classFileWriteStream.html" title="Wrapper of C file stream for output using fwrite(). ">FileWriteStream</a></code> 是一个含缓冲功能的输出流。它的用法与 <code><a class="el" href="../../da/da5/classFileReadStream.html" title="File byte stream for input using fread(). ">FileReadStream</a></code> 非常相似。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d2/d33/filewritestream_8h.html">rapidjson/filewritestream.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d9/d53/writer_8h.html">rapidjson/writer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/dc3/namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;</div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#aadee36db7064cc9894a75c848831cdae">Parse</a>(json);</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;output.json&quot;</span>, <span class="stringliteral">&quot;wb&quot;</span>); <span class="comment">// 非 Windows 平台使用 &quot;w&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> writeBuffer[65536];</div><div class="line"><a class="code" href="../../db/d85/classFileWriteStream.html">FileWriteStream</a> os(fp, writeBuffer, <span class="keyword">sizeof</span>(writeBuffer));</div><div class="line"></div><div class="line"><a class="code" href="../../d0/d88/classWriter.html">Writer&lt;FileWriteStream&gt;</a> writer(os);</div><div class="line">d.Accept(writer);</div><div class="line"></div><div class="line">fclose(fp);</div></div><!-- fragment --><p>它也可以把输出导向 <code>stdout</code>。</p>
<h1><a class="anchor" id="iostreamWrapper"></a>
iostream Wrapper</h1>
<p>基于用户的要求，RapidJSON 提供了正式的 <code>std::basic_istream</code> 和 <code>std::basic_ostream</code> 包装类。然而，请注意其性能会大大低于以上的其他流。</p>
<h2><a class="anchor" id="IStreamWrapper"></a>
IStreamWrapper</h2>
<p><code><a class="el" href="../../d0/d96/classIStreamWrapper.html">IStreamWrapper</a></code> 把任何继承自 <code>std::istream</code> 的类（如 <code>std::istringstream</code>、<code>std::stringstream</code>、<code>std::ifstream</code>、<code>std::fstream</code>）包装成 RapidJSON 的输入流。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../db/df5/document_8h.html">rapidjson/document.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d4/de4/istreamwrapper_8h.html">rapidjson/istreamwrapper.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/dc3/namespacerapidjson.html">rapidjson</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d8/dcc/namespacestd.html">std</a>;</div><div class="line"></div><div class="line">ifstream ifs(<span class="stringliteral">&quot;test.json&quot;</span>);</div><div class="line"><a class="code" href="../../d0/d96/classIStreamWrapper.html">IStreamWrapper</a> isw(ifs);</div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;</div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>(isw);</div></div><!-- fragment --><p>对于继承自 <code>std::wistream</code> 的类，则使用 <code>WIStreamWrapper</code>。</p>
<h2><a class="anchor" id="OStreamWrapper"></a>
OStreamWrapper</h2>
<p>相似地，<code><a class="el" href="../../d5/d9c/classOStreamWrapper.html">OStreamWrapper</a></code> 把任何继承自 <code>std::ostream</code> 的类（如 <code>std::ostringstream</code>、<code>std::stringstream</code>、<code>std::ofstream</code>、<code>std::fstream</code>）包装成 RapidJSON 的输出流。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../db/df5/document_8h.html">rapidjson/document.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../dc/dc7/ostreamwrapper_8h.html">rapidjson/ostreamwrapper.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d9/d53/writer_8h.html">rapidjson/writer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/dc3/namespacerapidjson.html">rapidjson</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d8/dcc/namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;</div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#aadee36db7064cc9894a75c848831cdae">Parse</a>(json);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">ofstream ofs(<span class="stringliteral">&quot;output.json&quot;</span>);</div><div class="line"><a class="code" href="../../d5/d9c/classOStreamWrapper.html">OStreamWrapper</a> osw(ofs);</div><div class="line"></div><div class="line"><a class="code" href="../../d0/d88/classWriter.html">Writer&lt;OStreamWrapper&gt;</a> writer(osw);</div><div class="line">d.Accept(writer);</div></div><!-- fragment --><p>对于继承自 <code>std::wistream</code> 的类，则使用 <code>WIStreamWrapper</code>。</p>
<h1><a class="anchor" id="EncodedStreams"></a>
Encoded Streams</h1>
<p>编码流（encoded streams）本身不存储 JSON，它们是通过包装字节流来提供基本的编码／解码功能。</p>
<p>如上所述，我们可以直接读入 UTF-8 字节流。然而，UTF-16 及 UTF-32 有字节序（endian）问题。要正确地处理字节序，需要在读取时把字节转换成字符（如对 UTF-16 使用 <code>wchar_t</code>），以及在写入时把字符转换为字节。</p>
<p>除此以外，我们也需要处理 <a href="http://en.wikipedia.org/wiki/Byte_order_mark">字节顺序标记（byte order mark, BOM）</a>。当从一个字节流读取时，需要检测 BOM，或者仅仅是把存在的 BOM 消去。当把 JSON 写入字节流时，也可选择写入 BOM。</p>
<p>若一个流的编码在编译期已知，你可使用 <code><a class="el" href="../../de/d19/classEncodedInputStream.html" title="Input byte stream wrapper with a statically bound encoding. ">EncodedInputStream</a></code> 及 <code><a class="el" href="../../d6/db2/classEncodedOutputStream.html" title="Output byte stream wrapper with statically bound encoding. ">EncodedOutputStream</a></code>。若一个流可能存储 UTF-8、UTF-16LE、UTF-16BE、UTF-32LE、UTF-32BE 的 JSON，并且编码只能在运行时得知，你便可以使用 <code><a class="el" href="../../d2/d48/classAutoUTFInputStream.html" title="Input stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFInputStream</a></code> 及 <code><a class="el" href="../../dd/dc9/classAutoUTFOutputStream.html" title="Output stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFOutputStream</a></code>。这些流定义在 <code>rapidjson/encodedstream.h</code>。</p>
<p>注意到，这些编码流可以施于文件以外的流。例如，你可以用编码流包装内存中的文件或自定义的字节流。</p>
<h2><a class="anchor" id="EncodedInputStream"></a>
EncodedInputStream</h2>
<p><code><a class="el" href="../../de/d19/classEncodedInputStream.html" title="Input byte stream wrapper with a statically bound encoding. ">EncodedInputStream</a></code> 含两个模板参数。第一个是 <code>Encoding</code> 类型，例如定义于 <code>rapidjson/encodings.h</code> 的 <code><a class="el" href="../../dd/dd8/structUTF8.html" title="UTF-8 encoding. ">UTF8</a></code>、<code><a class="el" href="../../d6/dda/structUTF16LE.html" title="UTF-16 little endian encoding. ">UTF16LE</a></code>。第二个参数是被包装的流的类型。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../db/df5/document_8h.html">rapidjson/document.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d1/d0d/filereadstream_8h.html">rapidjson/filereadstream.h</a>&quot;</span>   <span class="comment">// FileReadStream</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d8/d4d/encodedstream_8h.html">rapidjson/encodedstream.h</a>&quot;</span>    <span class="comment">// EncodedInputStream</span></div><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/dc3/namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;utf16le.json&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>); <span class="comment">// 非 Windows 平台使用 &quot;r&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> readBuffer[256];</div><div class="line"><a class="code" href="../../da/da5/classFileReadStream.html">FileReadStream</a> bis(fp, readBuffer, <span class="keyword">sizeof</span>(readBuffer));</div><div class="line"></div><div class="line"><a class="code" href="../../de/d19/classEncodedInputStream.html">EncodedInputStream&lt;UTF16LE&lt;&gt;</a>, <a class="code" href="../../da/da5/classFileReadStream.html">FileReadStream</a>&gt; eis(bis);  <span class="comment">// 用 eis 包装 bis</span></div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>; <span class="comment">// Document 为 GenericDocument&lt;UTF8&lt;&gt; &gt; </span></div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>&lt;0, <a class="code" href="../../d6/dda/structUTF16LE.html">UTF16LE&lt;&gt;</a> &gt;(eis);  <span class="comment">// 把 UTF-16LE 文件解析至内存中的 UTF-8</span></div><div class="line"></div><div class="line">fclose(fp);</div></div><!-- fragment --><h2><a class="anchor" id="EncodedOutputStream"></a>
EncodedOutputStream</h2>
<p><code><a class="el" href="../../d6/db2/classEncodedOutputStream.html" title="Output byte stream wrapper with statically bound encoding. ">EncodedOutputStream</a></code> 也是相似的，但它的构造函数有一个 <code>bool putBOM</code> 参数，用于控制是否在输出字节流写入 BOM。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d2/d33/filewritestream_8h.html">rapidjson/filewritestream.h</a>&quot;</span>  <span class="comment">// FileWriteStream</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d8/d4d/encodedstream_8h.html">rapidjson/encodedstream.h</a>&quot;</span>    <span class="comment">// EncodedOutputStream</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d9/d53/writer_8h.html">rapidjson/writer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;         <span class="comment">// Document 为 GenericDocument&lt;UTF8&lt;&gt; &gt; </span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;output_utf32le.json&quot;</span>, <span class="stringliteral">&quot;wb&quot;</span>); <span class="comment">// 非 Windows 平台使用 &quot;w&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> writeBuffer[256];</div><div class="line"><a class="code" href="../../db/d85/classFileWriteStream.html">FileWriteStream</a> bos(fp, writeBuffer, <span class="keyword">sizeof</span>(writeBuffer));</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> EncodedOutputStream&lt;UTF32LE&lt;&gt;, <a class="code" href="../../db/d85/classFileWriteStream.html">FileWriteStream</a>&gt; OutputStream;</div><div class="line">OutputStream eos(bos, <span class="keyword">true</span>);   <span class="comment">// 写入 BOM</span></div><div class="line"></div><div class="line"><a class="code" href="../../d0/d88/classWriter.html">Writer&lt;OutputStream, UTF32LE&lt;&gt;</a>, <a class="code" href="../../dd/dd8/structUTF8.html">UTF8&lt;&gt;</a>&gt; writer(eos);</div><div class="line">d.Accept(writer);   <span class="comment">// 这里从内存的 UTF-8 生成 UTF32-LE 文件</span></div><div class="line"></div><div class="line">fclose(fp);</div></div><!-- fragment --><h2><a class="anchor" id="AutoUTFInputStream"></a>
AutoUTFInputStream</h2>
<p>有时候，应用软件可能需要㲃理所有可支持的 JSON 编码。<code><a class="el" href="../../d2/d48/classAutoUTFInputStream.html" title="Input stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFInputStream</a></code> 会先使用 BOM 来检测编码。若 BOM 不存在，它便会使用合法 JSON 的特性来检测。若两种方法都失败，它就会倒退至构造函数提供的 UTF 类型。</p>
<p>由于字符（编码单元／code unit）可能是 8 位、16 位或 32 位，<code><a class="el" href="../../d2/d48/classAutoUTFInputStream.html" title="Input stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFInputStream</a></code> 需要一个能至少储存 32 位的字符类型。我们可以使用 <code>unsigned</code> 作为模板参数：</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../db/df5/document_8h.html">rapidjson/document.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d1/d0d/filereadstream_8h.html">rapidjson/filereadstream.h</a>&quot;</span>   <span class="comment">// FileReadStream</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d8/d4d/encodedstream_8h.html">rapidjson/encodedstream.h</a>&quot;</span>    <span class="comment">// AutoUTFInputStream</span></div><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/dc3/namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;any.json&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>); <span class="comment">// 非 Windows 平台使用 &quot;r&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> readBuffer[256];</div><div class="line"><a class="code" href="../../da/da5/classFileReadStream.html">FileReadStream</a> bis(fp, readBuffer, <span class="keyword">sizeof</span>(readBuffer));</div><div class="line"></div><div class="line"><a class="code" href="../../d2/d48/classAutoUTFInputStream.html">AutoUTFInputStream&lt;unsigned, FileReadStream&gt;</a> eis(bis);  <span class="comment">// 用 eis 包装 bis</span></div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;         <span class="comment">// Document 为 GenericDocument&lt;UTF8&lt;&gt; &gt; </span></div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>&lt;0, <a class="code" href="../../d1/d03/structAutoUTF.html">AutoUTF&lt;unsigned&gt;</a> &gt;(eis); <span class="comment">// 把任何 UTF 编码的文件解析至内存中的 UTF-8</span></div><div class="line"></div><div class="line">fclose(fp);</div></div><!-- fragment --><p>当要指定流的编码，可使用上面例子中 <code>ParseStream()</code> 的参数 <code><a class="el" href="../../d1/d03/structAutoUTF.html" title="Dynamically select encoding according to stream&#39;s runtime-specified UTF encoding type. ">AutoUTF</a>&lt;CharType&gt;</code>。</p>
<p>你可以使用 <code>UTFType GetType()</code> 去获取 UTF 类型，并且用 <code>HasBOM()</code> 检测输入流是否含有 BOM。</p>
<h2><a class="anchor" id="AutoUTFOutputStream"></a>
AutoUTFOutputStream</h2>
<p>相似地，要在运行时选择输出的编码，我们可使用 <code><a class="el" href="../../dd/dc9/classAutoUTFOutputStream.html" title="Output stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFOutputStream</a></code>。这个类本身并非「自动」。你需要在运行时指定 UTF 类型，以及是否写入 BOM。</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/dc3/namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> WriteJSONFile(FILE* fp, <a class="code" href="../../de/d06/encodings_8h.html#ac9448aedf514a5bb509bae73a9ce4e58">UTFType</a> type, <span class="keywordtype">bool</span> putBOM, <span class="keyword">const</span> <a class="code" href="../../da/dc7/classGenericDocument.html">Document</a>&amp; d) {</div><div class="line">    <span class="keywordtype">char</span> writeBuffer[256];</div><div class="line">    <a class="code" href="../../db/d85/classFileWriteStream.html">FileWriteStream</a> bos(fp, writeBuffer, <span class="keyword">sizeof</span>(writeBuffer));</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="../../dd/dc9/classAutoUTFOutputStream.html">AutoUTFOutputStream&lt;unsigned, FileWriteStream&gt;</a> OutputStream;</div><div class="line">    OutputStream eos(bos, type, putBOM);</div><div class="line"></div><div class="line">    <a class="code" href="../../d0/d88/classWriter.html">Writer&lt;OutputStream, UTF8&lt;&gt;</a>, <a class="code" href="../../d1/d03/structAutoUTF.html">AutoUTF&lt;&gt;</a> &gt; writer;</div><div class="line">    d.Accept(writer);</div><div class="line">}</div></div><!-- fragment --><p><code><a class="el" href="../../d2/d48/classAutoUTFInputStream.html" title="Input stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFInputStream</a></code>／<code><a class="el" href="../../dd/dc9/classAutoUTFOutputStream.html" title="Output stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFOutputStream</a></code> 是比 <code><a class="el" href="../../de/d19/classEncodedInputStream.html" title="Input byte stream wrapper with a statically bound encoding. ">EncodedInputStream</a></code>／<code><a class="el" href="../../d6/db2/classEncodedOutputStream.html" title="Output byte stream wrapper with statically bound encoding. ">EncodedOutputStream</a></code> 方便。但前者会产生一点运行期额外开销。</p>
<h1><a class="anchor" id="CustomStream"></a>
Custom Stream</h1>
<p>除了内存／文件流，使用者可创建自行定义适配 RapidJSON API 的流类。例如，你可以创建网络流、从压缩文件读取的流等等。</p>
<p>RapidJSON 利用模板结合不同的类型。只要一个类包含所有所需的接口，就可以作为一个流。流的接合定义在 <code>rapidjson/rapidjson.h</code> 的注释里：</p>
<div class="fragment"><div class="line">concept Stream {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="../../d8/df3/sha512-blocks_8c.html#ab0a0d1ad13c7e4d3cb38c89f7127c85a">Ch</a>;    </div><div class="line"></div><div class="line">    Ch Peek() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    Ch Take();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> Tell();</div><div class="line"></div><div class="line">    Ch* PutBegin();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Put(Ch c);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Flush();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> PutEnd(Ch* begin);</div><div class="line">}</div></div><!-- fragment --><p>输入流必须实现 <code>Peek()</code>、<code>Take()</code> 及 <code>Tell()</code>。 输出流必须实现 <code>Put()</code> 及 <code>Flush()</code>。 <code>PutBegin()</code> 及 <code>PutEnd()</code> 是特殊的接口，仅用于原位（*in situ*）解析。一般的流不需实现它们。然而，即使接口不需用于某些流，仍然需要提供空实现，否则会产生编译错误。</p>
<h2><a class="anchor" id="ExampleIStreamWrapper"></a>
Example: istream wrapper</h2>
<p>以下的简单例子是 <code>std::istream</code> 的包装类，它只需现 3 个函数。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyIStreamWrapper {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">char</span> <a class="code" href="../../d8/df3/sha512-blocks_8c.html#ab0a0d1ad13c7e4d3cb38c89f7127c85a">Ch</a>;</div><div class="line"></div><div class="line">    MyIStreamWrapper(std::istream&amp; is) : is_(is) {</div><div class="line">    }</div><div class="line"></div><div class="line">    Ch Peek()<span class="keyword"> const </span>{ <span class="comment">// 1</span></div><div class="line">        <span class="keywordtype">int</span> c = is_.peek();</div><div class="line">        <span class="keywordflow">return</span> c == std::char_traits&lt;char&gt;::eof() ? <span class="charliteral">&#39;\0&#39;</span> : (<a class="code" href="../../d8/df3/sha512-blocks_8c.html#ab0a0d1ad13c7e4d3cb38c89f7127c85a">Ch</a>)c;</div><div class="line">    }</div><div class="line"></div><div class="line">    Ch Take() { <span class="comment">// 2</span></div><div class="line">        <span class="keywordtype">int</span> c = is_.get();</div><div class="line">        <span class="keywordflow">return</span> c == std::char_traits&lt;char&gt;::eof() ? <span class="charliteral">&#39;\0&#39;</span> : (<a class="code" href="../../d8/df3/sha512-blocks_8c.html#ab0a0d1ad13c7e4d3cb38c89f7127c85a">Ch</a>)c;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> Tell()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (<span class="keywordtype">size_t</span>)is_.tellg(); } <span class="comment">// 3</span></div><div class="line"></div><div class="line">    Ch* PutBegin() { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> 0; }</div><div class="line">    <span class="keywordtype">void</span> Put(Ch) { assert(<span class="keyword">false</span>); }</div><div class="line">    <span class="keywordtype">void</span> Flush() { assert(<span class="keyword">false</span>); }</div><div class="line">    <span class="keywordtype">size_t</span> PutEnd(Ch*) { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> 0; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    MyIStreamWrapper(<span class="keyword">const</span> MyIStreamWrapper&amp;);</div><div class="line">    MyIStreamWrapper&amp; operator=(<span class="keyword">const</span> MyIStreamWrapper&amp;);</div><div class="line"></div><div class="line">    std::istream&amp; is_;</div><div class="line">};</div></div><!-- fragment --><p>使用者能用它来包装 <code>std::stringstream</code>、<code>std::ifstream</code> 的实例。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* json = <span class="stringliteral">&quot;[1,2,3,4]&quot;</span>;</div><div class="line">std::stringstream ss(json);</div><div class="line">MyIStreamWrapper is(ss);</div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;</div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>(is);</div></div><!-- fragment --><p>但要注意，由于标准库的内部开销问，此实现的性能可能不如 RapidJSON 的内存／文件流。</p>
<h2><a class="anchor" id="ExampleOStreamWrapper"></a>
Example: ostream wrapper</h2>
<p>以下的例子是 <code>std::istream</code> 的包装类，它只需实现 2 个函数。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyOStreamWrapper {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">char</span> <a class="code" href="../../d8/df3/sha512-blocks_8c.html#ab0a0d1ad13c7e4d3cb38c89f7127c85a">Ch</a>;</div><div class="line"></div><div class="line">    <a class="code" href="../../dc/dc7/ostreamwrapper_8h.html#aa8f833ae8c21c308bc48717f056ac4b6">OStreamWrapper</a>(std::ostream&amp; os) : os_(os) {</div><div class="line">    }</div><div class="line"></div><div class="line">    Ch Peek()<span class="keyword"> const </span>{ assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> <span class="charliteral">&#39;\0&#39;</span>; }</div><div class="line">    Ch Take() { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> <span class="charliteral">&#39;\0&#39;</span>; }</div><div class="line">    <span class="keywordtype">size_t</span> Tell()<span class="keyword"> const </span>{  }</div><div class="line"></div><div class="line">    Ch* PutBegin() { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> 0; }</div><div class="line">    <span class="keywordtype">void</span> Put(Ch c) { os_.put(c); }                  <span class="comment">// 1</span></div><div class="line">    <span class="keywordtype">void</span> Flush() { os_.flush(); }                   <span class="comment">// 2</span></div><div class="line">    <span class="keywordtype">size_t</span> PutEnd(Ch*) { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> 0; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    MyOStreamWrapper(<span class="keyword">const</span> MyOStreamWrapper&amp;);</div><div class="line">    MyOStreamWrapper&amp; operator=(<span class="keyword">const</span> MyOStreamWrapper&amp;);</div><div class="line"></div><div class="line">    std::ostream&amp; os_;</div><div class="line">};</div></div><!-- fragment --><p>使用者能用它来包装 <code>std::stringstream</code>、<code>std::ofstream</code> 的实例。</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">std::stringstream ss;</div><div class="line">MyOStreamWrapper os(ss);</div><div class="line"></div><div class="line"><a class="code" href="../../d0/d88/classWriter.html">Writer&lt;MyOStreamWrapper&gt;</a> writer(os);</div><div class="line">d.Accept(writer);</div></div><!-- fragment --><p>但要注意，由于标准库的内部开销问，此实现的性能可能不如 RapidJSON 的内存／文件流。</p>
<h1><a class="anchor" id="Summary"></a>
Summary</h1>
<p>本节描述了 RapidJSON 提供的各种流的类。内存流很简单。若 JSON 存储在文件中，文件流可减少 JSON 解析及生成所需的内存量。编码流在字节流和字符流之间作转换。最后，使用者可使用一个简单接口创建自定义的流。 </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 2 2023 19:23:33 for Monero by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
