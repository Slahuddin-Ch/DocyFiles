<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Monero: Stream</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Monero
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Stream </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#MemoryStreams">Memory Streams</a><ul><li class="level2"><a href="#StringStream">StringStream (Input)</a></li>
<li class="level2"><a href="#StringBuffer">StringBuffer (Output)</a></li>
</ul>
</li>
<li class="level1"><a href="#FileStreams">File Streams</a><ul><li class="level2"><a href="#FileReadStream">FileReadStream (Input)</a></li>
<li class="level2"><a href="#FileWriteStream">FileWriteStream (Output)</a></li>
</ul>
</li>
<li class="level1"><a href="#iostreamWrapper">iostream Wrapper</a><ul><li class="level2"><a href="#IStreamWrapper">IStreamWrapper</a></li>
<li class="level2"><a href="#OStreamWrapper">OStreamWrapper</a></li>
</ul>
</li>
<li class="level1"><a href="#EncodedStreams">Encoded Streams</a><ul><li class="level2"><a href="#EncodedInputStream">EncodedInputStream</a></li>
<li class="level2"><a href="#EncodedOutputStream">EncodedOutputStream</a></li>
<li class="level2"><a href="#AutoUTFInputStream">AutoUTFInputStream</a></li>
<li class="level2"><a href="#AutoUTFOutputStream">AutoUTFOutputStream</a></li>
</ul>
</li>
<li class="level1"><a href="#CustomStream">Custom Stream</a><ul><li class="level2"><a href="#ExampleIStreamWrapper">Example: istream wrapper</a></li>
<li class="level2"><a href="#ExampleOStreamWrapper">Example: ostream wrapper</a></li>
</ul>
</li>
<li class="level1"><a href="#Summary">Summary</a></li>
</ul>
</div>
<div class="textblock"><p>In RapidJSON, <code><a class="el" href="../../dc/dc3/classrapidjson_1_1Stream.html" title="Concept for reading and writing characters. ">rapidjson::Stream</a></code> is a concept for reading/writing JSON. Here we first show how to use streams provided. And then see how to create a custom stream.</p>
<h1><a class="anchor" id="MemoryStreams"></a>
Memory Streams</h1>
<p>Memory streams store JSON in memory.</p>
<h2><a class="anchor" id="StringStream"></a>
StringStream (Input)</h2>
<p><code>StringStream</code> is the most basic input stream. It represents a complete, read-only JSON stored in memory. It is defined in <code>rapidjson/rapidjson.h</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../db/df5/document_8h.html">rapidjson/document.h</a>&quot;</span> <span class="comment">// will include &quot;rapidjson/rapidjson.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/dc3/namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> json[] = <span class="stringliteral">&quot;[1, 2, 3, 4]&quot;</span>;</div><div class="line"><a class="code" href="../../d2/d8a/structGenericStringStream.html">StringStream</a> <a class="code" href="../../de/dc6/minissdp_8c.html#ab87f55bd0280d90925050a4188c14ab5">s</a>(json);</div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;</div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>(s);</div></div><!-- fragment --><p>Since this is very common usage, <code>Document::Parse(const char*)</code> is provided to do exactly the same as above:</p>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> json[] = <span class="stringliteral">&quot;[1, 2, 3, 4]&quot;</span>;</div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;</div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#aadee36db7064cc9894a75c848831cdae">Parse</a>(json);</div></div><!-- fragment --><p>Note that, <code>StringStream</code> is a typedef of <code><a class="el" href="../../d2/d8a/structGenericStringStream.html" title="Read-only string stream. ">GenericStringStream</a>&lt;<a class="el" href="../../dd/dd8/structUTF8.html" title="UTF-8 encoding. ">UTF8</a>&lt;&gt; &gt;</code>, user may use another encodings to represent the character set of the stream.</p>
<h2><a class="anchor" id="StringBuffer"></a>
StringBuffer (Output)</h2>
<p><code>StringBuffer</code> is a simple output stream. It allocates a memory buffer for writing the whole JSON. Use <code>GetString()</code> to obtain the buffer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d7/dde/stringbuffer_8h.html">rapidjson/stringbuffer.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d9/d53/writer_8h.html">rapidjson/writer.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="../../d7/d69/classGenericStringBuffer.html">StringBuffer</a> <a class="code" href="../../d5/df9/byte__slice_8cpp.html#a59965c4f502e11ebf0b78cb2e8031fdd">buffer</a>;</div><div class="line"><a class="code" href="../../d0/d88/classWriter.html">Writer&lt;StringBuffer&gt;</a> writer(buffer);</div><div class="line">d.Accept(writer);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="../../d8/d7f/namespacegmock__output__test.html#a4277f8598ba3835393fe82e82d09375d">output</a> = buffer.<a class="code" href="../../d7/d69/classGenericStringBuffer.html#ab06b8c5f1385bd3dfd4caea8b7510f0b">GetString</a>();</div></div><!-- fragment --><p>When the buffer is full, it will increases the capacity automatically. The default capacity is 256 characters (256 bytes for <a class="el" href="../../dd/dd8/structUTF8.html" title="UTF-8 encoding. ">UTF8</a>, 512 bytes for <a class="el" href="../../d2/d54/structUTF16.html" title="UTF-16 encoding. ">UTF16</a>, etc.). User can provide an allocator and a initial capacity.</p>
<div class="fragment"><div class="line"><a class="code" href="../../d7/d69/classGenericStringBuffer.html">StringBuffer</a> <a class="code" href="../../db/da7/namespacerandomx.html#a45c7644dc7dd15cc83bfd4e1c2a35c31">buffer1</a>(0, 1024); <span class="comment">// Use its allocator, initial size = 1024</span></div><div class="line"><a class="code" href="../../d7/d69/classGenericStringBuffer.html">StringBuffer</a> <a class="code" href="../../db/da7/namespacerandomx.html#aef3319eddf0782c9fcb47dde6c99b6fa">buffer2</a>(allocator, 1024);</div></div><!-- fragment --><p>By default, <code>StringBuffer</code> will instantiate an internal allocator.</p>
<p>Similarly, <code>StringBuffer</code> is a typedef of <code><a class="el" href="../../d7/d69/classGenericStringBuffer.html" title="Represents an in-memory output stream. ">GenericStringBuffer</a>&lt;<a class="el" href="../../dd/dd8/structUTF8.html" title="UTF-8 encoding. ">UTF8</a>&lt;&gt; &gt;</code>.</p>
<h1><a class="anchor" id="FileStreams"></a>
File Streams</h1>
<p>When parsing a JSON from file, you may read the whole JSON into memory and use <code>StringStream</code> above.</p>
<p>However, if the JSON is big, or memory is limited, you can use <code><a class="el" href="../../da/da5/classFileReadStream.html" title="File byte stream for input using fread(). ">FileReadStream</a></code>. It only read a part of JSON from file into buffer, and then let the part be parsed. If it runs out of characters in the buffer, it will read the next part from file.</p>
<h2><a class="anchor" id="FileReadStream"></a>
FileReadStream (Input)</h2>
<p><code><a class="el" href="../../da/da5/classFileReadStream.html" title="File byte stream for input using fread(). ">FileReadStream</a></code> reads the file via a <code>FILE</code> pointer. And user need to provide a buffer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d1/d0d/filereadstream_8h.html">rapidjson/filereadstream.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/dc3/namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;big.json&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>); <span class="comment">// non-Windows use &quot;r&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> readBuffer[65536];</div><div class="line"><a class="code" href="../../da/da5/classFileReadStream.html">FileReadStream</a> is(fp, readBuffer, <span class="keyword">sizeof</span>(readBuffer));</div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;</div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>(is);</div><div class="line"></div><div class="line">fclose(fp);</div></div><!-- fragment --><p>Different from string streams, <code><a class="el" href="../../da/da5/classFileReadStream.html" title="File byte stream for input using fread(). ">FileReadStream</a></code> is byte stream. It does not handle encodings. If the file is not UTF-8, the byte stream can be wrapped in a <code><a class="el" href="../../de/d19/classEncodedInputStream.html" title="Input byte stream wrapper with a statically bound encoding. ">EncodedInputStream</a></code>. It will be discussed very soon.</p>
<p>Apart from reading file, user can also use <code><a class="el" href="../../da/da5/classFileReadStream.html" title="File byte stream for input using fread(). ">FileReadStream</a></code> to read <code>stdin</code>.</p>
<h2><a class="anchor" id="FileWriteStream"></a>
FileWriteStream (Output)</h2>
<p><code><a class="el" href="../../db/d85/classFileWriteStream.html" title="Wrapper of C file stream for output using fwrite(). ">FileWriteStream</a></code> is buffered output stream. Its usage is very similar to <code><a class="el" href="../../da/da5/classFileReadStream.html" title="File byte stream for input using fread(). ">FileReadStream</a></code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d2/d33/filewritestream_8h.html">rapidjson/filewritestream.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d9/d53/writer_8h.html">rapidjson/writer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/dc3/namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;</div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#aadee36db7064cc9894a75c848831cdae">Parse</a>(json);</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;output.json&quot;</span>, <span class="stringliteral">&quot;wb&quot;</span>); <span class="comment">// non-Windows use &quot;w&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> writeBuffer[65536];</div><div class="line"><a class="code" href="../../db/d85/classFileWriteStream.html">FileWriteStream</a> os(fp, writeBuffer, <span class="keyword">sizeof</span>(writeBuffer));</div><div class="line"></div><div class="line"><a class="code" href="../../d0/d88/classWriter.html">Writer&lt;FileWriteStream&gt;</a> writer(os);</div><div class="line">d.Accept(writer);</div><div class="line"></div><div class="line">fclose(fp);</div></div><!-- fragment --><p>It can also directs the output to <code>stdout</code>.</p>
<h1><a class="anchor" id="iostreamWrapper"></a>
iostream Wrapper</h1>
<p>Due to users' requests, RapidJSON provided official wrappers for <code>std::basic_istream</code> and <code>std::basic_ostream</code>. However, please note that the performance will be much lower than the other streams above.</p>
<h2><a class="anchor" id="IStreamWrapper"></a>
IStreamWrapper</h2>
<p><code><a class="el" href="../../d0/d96/classIStreamWrapper.html">IStreamWrapper</a></code> wraps any class drived from <code>std::istream</code>, such as <code>std::istringstream</code>, <code>std::stringstream</code>, <code>std::ifstream</code>, <code>std::fstream</code>, into RapidJSON's input stream.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../db/df5/document_8h.html">rapidjson/document.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d4/de4/istreamwrapper_8h.html">rapidjson/istreamwrapper.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/dc3/namespacerapidjson.html">rapidjson</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d8/dcc/namespacestd.html">std</a>;</div><div class="line"></div><div class="line">ifstream ifs(<span class="stringliteral">&quot;test.json&quot;</span>);</div><div class="line"><a class="code" href="../../d0/d96/classIStreamWrapper.html">IStreamWrapper</a> isw(ifs);</div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;</div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>(isw);</div></div><!-- fragment --><p>For classes derived from <code>std::wistream</code>, use <code>WIStreamWrapper</code>.</p>
<h2><a class="anchor" id="OStreamWrapper"></a>
OStreamWrapper</h2>
<p>Similarly, <code><a class="el" href="../../d5/d9c/classOStreamWrapper.html">OStreamWrapper</a></code> wraps any class derived from <code>std::ostream</code>, such as <code>std::ostringstream</code>, <code>std::stringstream</code>, <code>std::ofstream</code>, <code>std::fstream</code>, into RapidJSON's input stream.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../db/df5/document_8h.html">rapidjson/document.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../dc/dc7/ostreamwrapper_8h.html">rapidjson/ostreamwrapper.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d9/d53/writer_8h.html">rapidjson/writer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/dc3/namespacerapidjson.html">rapidjson</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d8/dcc/namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;</div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#aadee36db7064cc9894a75c848831cdae">Parse</a>(json);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">ofstream ofs(<span class="stringliteral">&quot;output.json&quot;</span>);</div><div class="line"><a class="code" href="../../d5/d9c/classOStreamWrapper.html">OStreamWrapper</a> osw(ofs);</div><div class="line"></div><div class="line"><a class="code" href="../../d0/d88/classWriter.html">Writer&lt;OStreamWrapper&gt;</a> writer(osw);</div><div class="line">d.Accept(writer);</div></div><!-- fragment --><p>For classes derived from <code>std::wostream</code>, use <code>WOStreamWrapper</code>.</p>
<h1><a class="anchor" id="EncodedStreams"></a>
Encoded Streams</h1>
<p>Encoded streams do not contain JSON itself, but they wrap byte streams to provide basic encoding/decoding function.</p>
<p>As mentioned above, UTF-8 byte streams can be read directly. However, UTF-16 and UTF-32 have endian issue. To handle endian correctly, it needs to convert bytes into characters (e.g. <code>wchar_t</code> for UTF-16) while reading, and characters into bytes while writing.</p>
<p>Besides, it also need to handle <a href="http://en.wikipedia.org/wiki/Byte_order_mark">byte order mark (BOM)</a>. When reading from a byte stream, it is needed to detect or just consume the BOM if exists. When writing to a byte stream, it can optionally write BOM.</p>
<p>If the encoding of stream is known in compile-time, you may use <code><a class="el" href="../../de/d19/classEncodedInputStream.html" title="Input byte stream wrapper with a statically bound encoding. ">EncodedInputStream</a></code> and <code><a class="el" href="../../d6/db2/classEncodedOutputStream.html" title="Output byte stream wrapper with statically bound encoding. ">EncodedOutputStream</a></code>. If the stream can be UTF-8, UTF-16LE, UTF-16BE, UTF-32LE, UTF-32BE JSON, and it is only known in runtime, you may use <code><a class="el" href="../../d2/d48/classAutoUTFInputStream.html" title="Input stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFInputStream</a></code> and <code><a class="el" href="../../dd/dc9/classAutoUTFOutputStream.html" title="Output stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFOutputStream</a></code>. These streams are defined in <code>rapidjson/encodedstream.h</code>.</p>
<p>Note that, these encoded streams can be applied to streams other than file. For example, you may have a file in memory, or a custom byte stream, be wrapped in encoded streams.</p>
<h2><a class="anchor" id="EncodedInputStream"></a>
EncodedInputStream</h2>
<p><code><a class="el" href="../../de/d19/classEncodedInputStream.html" title="Input byte stream wrapper with a statically bound encoding. ">EncodedInputStream</a></code> has two template parameters. The first one is a <code>Encoding</code> class, such as <code><a class="el" href="../../dd/dd8/structUTF8.html" title="UTF-8 encoding. ">UTF8</a></code>, <code><a class="el" href="../../d6/dda/structUTF16LE.html" title="UTF-16 little endian encoding. ">UTF16LE</a></code>, defined in <code>rapidjson/encodings.h</code>. The second one is the class of stream to be wrapped.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../db/df5/document_8h.html">rapidjson/document.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d1/d0d/filereadstream_8h.html">rapidjson/filereadstream.h</a>&quot;</span>   <span class="comment">// FileReadStream</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d8/d4d/encodedstream_8h.html">rapidjson/encodedstream.h</a>&quot;</span>    <span class="comment">// EncodedInputStream</span></div><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/dc3/namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;utf16le.json&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>); <span class="comment">// non-Windows use &quot;r&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> readBuffer[256];</div><div class="line"><a class="code" href="../../da/da5/classFileReadStream.html">FileReadStream</a> bis(fp, readBuffer, <span class="keyword">sizeof</span>(readBuffer));</div><div class="line"></div><div class="line"><a class="code" href="../../de/d19/classEncodedInputStream.html">EncodedInputStream&lt;UTF16LE&lt;&gt;</a>, <a class="code" href="../../da/da5/classFileReadStream.html">FileReadStream</a>&gt; eis(bis);  <span class="comment">// wraps bis into eis</span></div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>; <span class="comment">// Document is GenericDocument&lt;UTF8&lt;&gt; &gt; </span></div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>&lt;0, <a class="code" href="../../d6/dda/structUTF16LE.html">UTF16LE&lt;&gt;</a> &gt;(eis);  <span class="comment">// Parses UTF-16LE file into UTF-8 in memory</span></div><div class="line"></div><div class="line">fclose(fp);</div></div><!-- fragment --><h2><a class="anchor" id="EncodedOutputStream"></a>
EncodedOutputStream</h2>
<p><code><a class="el" href="../../d6/db2/classEncodedOutputStream.html" title="Output byte stream wrapper with statically bound encoding. ">EncodedOutputStream</a></code> is similar but it has a <code>bool putBOM</code> parameter in the constructor, controlling whether to write BOM into output byte stream.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d2/d33/filewritestream_8h.html">rapidjson/filewritestream.h</a>&quot;</span>  <span class="comment">// FileWriteStream</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d8/d4d/encodedstream_8h.html">rapidjson/encodedstream.h</a>&quot;</span>    <span class="comment">// EncodedOutputStream</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d9/d53/writer_8h.html">rapidjson/writer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;         <span class="comment">// Document is GenericDocument&lt;UTF8&lt;&gt; &gt; </span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;output_utf32le.json&quot;</span>, <span class="stringliteral">&quot;wb&quot;</span>); <span class="comment">// non-Windows use &quot;w&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> writeBuffer[256];</div><div class="line"><a class="code" href="../../db/d85/classFileWriteStream.html">FileWriteStream</a> bos(fp, writeBuffer, <span class="keyword">sizeof</span>(writeBuffer));</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d6/db2/classEncodedOutputStream.html">EncodedOutputStream&lt;UTF32LE&lt;&gt;</a>, <a class="code" href="../../db/d85/classFileWriteStream.html">FileWriteStream</a>&gt; OutputStream;</div><div class="line">OutputStream eos(bos, <span class="keyword">true</span>);   <span class="comment">// Write BOM</span></div><div class="line"></div><div class="line"><a class="code" href="../../d0/d88/classWriter.html">Writer&lt;OutputStream, UTF32LE&lt;&gt;</a>, <a class="code" href="../../dd/dd8/structUTF8.html">UTF8&lt;&gt;</a>&gt; writer(eos);</div><div class="line">d.Accept(writer);   <span class="comment">// This generates UTF32-LE file from UTF-8 in memory</span></div><div class="line"></div><div class="line">fclose(fp);</div></div><!-- fragment --><h2><a class="anchor" id="AutoUTFInputStream"></a>
AutoUTFInputStream</h2>
<p>Sometimes an application may want to handle all supported JSON encoding. <code><a class="el" href="../../d2/d48/classAutoUTFInputStream.html" title="Input stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFInputStream</a></code> will detection encoding by BOM first. If BOM is unavailable, it will use characteristics of valid JSON to make detection. If neither method success, it falls back to the UTF type provided in constructor.</p>
<p>Since the characters (code units) may be 8-bit, 16-bit or 32-bit. <code><a class="el" href="../../d2/d48/classAutoUTFInputStream.html" title="Input stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFInputStream</a></code> requires a character type which can hold at least 32-bit. We may use <code>unsigned</code>, as in the template parameter:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../db/df5/document_8h.html">rapidjson/document.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d1/d0d/filereadstream_8h.html">rapidjson/filereadstream.h</a>&quot;</span>   <span class="comment">// FileReadStream</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d8/d4d/encodedstream_8h.html">rapidjson/encodedstream.h</a>&quot;</span>    <span class="comment">// AutoUTFInputStream</span></div><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/dc3/namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;any.json&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>); <span class="comment">// non-Windows use &quot;r&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> readBuffer[256];</div><div class="line"><a class="code" href="../../da/da5/classFileReadStream.html">FileReadStream</a> bis(fp, readBuffer, <span class="keyword">sizeof</span>(readBuffer));</div><div class="line"></div><div class="line"><a class="code" href="../../d2/d48/classAutoUTFInputStream.html">AutoUTFInputStream&lt;unsigned, FileReadStream&gt;</a> eis(bis);  <span class="comment">// wraps bis into eis</span></div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;         <span class="comment">// Document is GenericDocument&lt;UTF8&lt;&gt; &gt; </span></div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>&lt;0, <a class="code" href="../../d1/d03/structAutoUTF.html">AutoUTF&lt;unsigned&gt;</a> &gt;(eis); <span class="comment">// This parses any UTF file into UTF-8 in memory</span></div><div class="line"></div><div class="line">fclose(fp);</div></div><!-- fragment --><p>When specifying the encoding of stream, uses <code><a class="el" href="../../d1/d03/structAutoUTF.html" title="Dynamically select encoding according to stream&#39;s runtime-specified UTF encoding type. ">AutoUTF</a>&lt;CharType&gt;</code> as in <code>ParseStream()</code> above.</p>
<p>You can obtain the type of UTF via <code>UTFType GetType()</code>. And check whether a BOM is found by <code>HasBOM()</code></p>
<h2><a class="anchor" id="AutoUTFOutputStream"></a>
AutoUTFOutputStream</h2>
<p>Similarly, to choose encoding for output during runtime, we can use <code><a class="el" href="../../dd/dc9/classAutoUTFOutputStream.html" title="Output stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFOutputStream</a></code>. This class is not automatic <em>per se</em>. You need to specify the UTF type and whether to write BOM in runtime.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/dc3/namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> WriteJSONFile(FILE* fp, <a class="code" href="../../de/d06/encodings_8h.html#ac9448aedf514a5bb509bae73a9ce4e58">UTFType</a> <a class="code" href="../../d5/d14/namespacerandomx_1_1ExecutionPort.html#aa48fbe57c27c2ceb8b0cf85777d0807a">type</a>, <span class="keywordtype">bool</span> putBOM, <span class="keyword">const</span> <a class="code" href="../../da/dc7/classGenericDocument.html">Document</a>&amp; d) {</div><div class="line">    <span class="keywordtype">char</span> writeBuffer[256];</div><div class="line">    <a class="code" href="../../db/d85/classFileWriteStream.html">FileWriteStream</a> bos(fp, writeBuffer, <span class="keyword">sizeof</span>(writeBuffer));</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="../../dd/dc9/classAutoUTFOutputStream.html">AutoUTFOutputStream&lt;unsigned, FileWriteStream&gt;</a> OutputStream;</div><div class="line">    OutputStream eos(bos, type, putBOM);</div><div class="line"></div><div class="line">    <a class="code" href="../../d0/d88/classWriter.html">Writer&lt;OutputStream, UTF8&lt;&gt;</a>, <a class="code" href="../../d1/d03/structAutoUTF.html">AutoUTF&lt;&gt;</a> &gt; writer;</div><div class="line">    d.Accept(writer);</div><div class="line">}</div></div><!-- fragment --><p><code><a class="el" href="../../d2/d48/classAutoUTFInputStream.html" title="Input stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFInputStream</a></code> and <code><a class="el" href="../../dd/dc9/classAutoUTFOutputStream.html" title="Output stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFOutputStream</a></code> is more convenient than <code><a class="el" href="../../de/d19/classEncodedInputStream.html" title="Input byte stream wrapper with a statically bound encoding. ">EncodedInputStream</a></code> and <code><a class="el" href="../../d6/db2/classEncodedOutputStream.html" title="Output byte stream wrapper with statically bound encoding. ">EncodedOutputStream</a></code>. They just incur a little bit runtime overheads.</p>
<h1><a class="anchor" id="CustomStream"></a>
Custom Stream</h1>
<p>In addition to memory/file streams, user can create their own stream classes which fits RapidJSON's API. For example, you may create network stream, stream from compressed file, etc.</p>
<p>RapidJSON combines different types using templates. A class containing all required interface can be a stream. The Stream interface is defined in comments of <code>rapidjson/rapidjson.h</code>:</p>
<div class="fragment"><div class="line">concept Stream {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="../../d8/df3/sha512-blocks_8c.html#ab0a0d1ad13c7e4d3cb38c89f7127c85a">Ch</a>;    </div><div class="line"></div><div class="line">    <a class="code" href="../../d8/df3/sha512-blocks_8c.html#ab0a0d1ad13c7e4d3cb38c89f7127c85a">Ch</a> Peek() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="../../d8/df3/sha512-blocks_8c.html#ab0a0d1ad13c7e4d3cb38c89f7127c85a">Ch</a> Take();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> Tell();</div><div class="line"></div><div class="line">    <a class="code" href="../../d8/df3/sha512-blocks_8c.html#ab0a0d1ad13c7e4d3cb38c89f7127c85a">Ch</a>* PutBegin();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Put(<a class="code" href="../../d8/df3/sha512-blocks_8c.html#ab0a0d1ad13c7e4d3cb38c89f7127c85a">Ch</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a2bce00014695ec26226c92abd4eccb9a">c</a>);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Flush();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> PutEnd(<a class="code" href="../../d8/df3/sha512-blocks_8c.html#ab0a0d1ad13c7e4d3cb38c89f7127c85a">Ch</a>* begin);</div><div class="line">}</div></div><!-- fragment --><p>For input stream, they must implement <code>Peek()</code>, <code>Take()</code> and <code>Tell()</code>. For output stream, they must implement <code>Put()</code> and <code>Flush()</code>. There are two special interface, <code>PutBegin()</code> and <code>PutEnd()</code>, which are only for <em>in situ</em> parsing. Normal streams do not implement them. However, if the interface is not needed for a particular stream, it is still need to a dummy implementation, otherwise will generate compilation error.</p>
<h2><a class="anchor" id="ExampleIStreamWrapper"></a>
Example: istream wrapper</h2>
<p>The following example is a simple wrapper of <code>std::istream</code>, which only implements 3 functions.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyIStreamWrapper {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">char</span> <a class="code" href="../../d8/df3/sha512-blocks_8c.html#ab0a0d1ad13c7e4d3cb38c89f7127c85a">Ch</a>;</div><div class="line"></div><div class="line">    MyIStreamWrapper(std::istream&amp; is) : is_(is) {</div><div class="line">    }</div><div class="line"></div><div class="line">    Ch Peek()<span class="keyword"> const </span>{ <span class="comment">// 1</span></div><div class="line">        <span class="keywordtype">int</span> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a2bce00014695ec26226c92abd4eccb9a">c</a> = is_.peek();</div><div class="line">        <span class="keywordflow">return</span> c == std::char_traits&lt;char&gt;::eof() ? <span class="charliteral">&#39;\0&#39;</span> : (<a class="code" href="../../d8/df3/sha512-blocks_8c.html#ab0a0d1ad13c7e4d3cb38c89f7127c85a">Ch</a>)c;</div><div class="line">    }</div><div class="line"></div><div class="line">    Ch Take() { <span class="comment">// 2</span></div><div class="line">        <span class="keywordtype">int</span> c = is_.get();</div><div class="line">        <span class="keywordflow">return</span> c == std::char_traits&lt;char&gt;::eof() ? <span class="charliteral">&#39;\0&#39;</span> : (<a class="code" href="../../d8/df3/sha512-blocks_8c.html#ab0a0d1ad13c7e4d3cb38c89f7127c85a">Ch</a>)c;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> Tell()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (<span class="keywordtype">size_t</span>)is_.tellg(); } <span class="comment">// 3</span></div><div class="line"></div><div class="line">    Ch* PutBegin() { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> 0; }</div><div class="line">    <span class="keywordtype">void</span> Put(Ch) { assert(<span class="keyword">false</span>); }</div><div class="line">    <span class="keywordtype">void</span> Flush() { assert(<span class="keyword">false</span>); }</div><div class="line">    <span class="keywordtype">size_t</span> PutEnd(Ch*) { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> 0; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    MyIStreamWrapper(<span class="keyword">const</span> MyIStreamWrapper&amp;);</div><div class="line">    MyIStreamWrapper&amp; operator=(<span class="keyword">const</span> MyIStreamWrapper&amp;);</div><div class="line"></div><div class="line">    std::istream&amp; is_;</div><div class="line">};</div></div><!-- fragment --><p>User can use it to wrap instances of <code>std::stringstream</code>, <code>std::ifstream</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* json = <span class="stringliteral">&quot;[1,2,3,4]&quot;</span>;</div><div class="line">std::stringstream ss(json);</div><div class="line">MyIStreamWrapper is(ss);</div><div class="line"></div><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;</div><div class="line">d.<a class="code" href="../../da/dc7/classGenericDocument.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>(is);</div></div><!-- fragment --><p>Note that, this implementation may not be as efficient as RapidJSON's memory or file streams, due to internal overheads of the standard library.</p>
<h2><a class="anchor" id="ExampleOStreamWrapper"></a>
Example: ostream wrapper</h2>
<p>The following example is a simple wrapper of <code>std::istream</code>, which only implements 2 functions.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyOStreamWrapper {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">char</span> <a class="code" href="../../d8/df3/sha512-blocks_8c.html#ab0a0d1ad13c7e4d3cb38c89f7127c85a">Ch</a>;</div><div class="line"></div><div class="line">    MyOStreamWrapper(std::ostream&amp; os) : os_(os) {</div><div class="line">    }</div><div class="line"></div><div class="line">    Ch Peek()<span class="keyword"> const </span>{ assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> <span class="charliteral">&#39;\0&#39;</span>; }</div><div class="line">    Ch Take() { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> <span class="charliteral">&#39;\0&#39;</span>; }</div><div class="line">    <span class="keywordtype">size_t</span> Tell()<span class="keyword"> const </span>{  }</div><div class="line"></div><div class="line">    Ch* PutBegin() { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> 0; }</div><div class="line">    <span class="keywordtype">void</span> Put(Ch c) { os_.put(c); }                  <span class="comment">// 1</span></div><div class="line">    <span class="keywordtype">void</span> Flush() { os_.flush(); }                   <span class="comment">// 2</span></div><div class="line">    <span class="keywordtype">size_t</span> PutEnd(Ch*) { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> 0; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    MyOStreamWrapper(<span class="keyword">const</span> MyOStreamWrapper&amp;);</div><div class="line">    MyOStreamWrapper&amp; operator=(<span class="keyword">const</span> MyOStreamWrapper&amp;);</div><div class="line"></div><div class="line">    std::ostream&amp; os_;</div><div class="line">};</div></div><!-- fragment --><p>User can use it to wrap instances of <code>std::stringstream</code>, <code>std::ofstream</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/dc7/classGenericDocument.html">Document</a> <a class="code" href="../../d5/dd5/namespacepymoduletest.html#a59e9c18f53021b0c37dedfbce7686f1c">d</a>;</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">std::stringstream ss;</div><div class="line">MyOStreamWrapper os(ss);</div><div class="line"></div><div class="line"><a class="code" href="../../d0/d88/classWriter.html">Writer&lt;MyOStreamWrapper&gt;</a> writer(os);</div><div class="line">d.Accept(writer);</div></div><!-- fragment --><p>Note that, this implementation may not be as efficient as RapidJSON's memory or file streams, due to internal overheads of the standard library.</p>
<h1><a class="anchor" id="Summary"></a>
Summary</h1>
<p>This section describes stream classes available in RapidJSON. Memory streams are simple. File stream can reduce the memory required during JSON parsing and generation, if the JSON is stored in file system. Encoded streams converts between byte streams and character streams. Finally, user may create custom streams using a simple interface. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 2 2023 19:23:33 for Monero by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
