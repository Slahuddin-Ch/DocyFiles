<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Monero: RandomX</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Monero
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">RandomX </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>RandomX is a proof-of-work (PoW) algorithm that is optimized for general-purpose CPUs. RandomX uses random code execution (hence the name) together with several memory-hard techniques to minimize the efficiency advantage of specialized hardware.</p>
<h2>Overview</h2>
<p>RandomX utilizes a virtual machine that executes programs in a special instruction set that consists of integer math, floating point math and branches. These programs can be translated into the CPU's native machine code on the fly (example: <a href="../../doc/program.asm">program.asm</a>). At the end, the outputs of the executed programs are consolidated into a 256-bit result using a cryptographic hashing function (<a href="https://blake2.net/">Blake2b</a>).</p>
<p>RandomX can operate in two main modes with different memory requirements:</p>
<ul>
<li><b>Fast mode</b> - requires 2080 MiB of shared memory.</li>
<li><b>Light mode</b> - requires only 256 MiB of shared memory, but runs significantly slower</li>
</ul>
<p>Both modes are interchangeable as they give the same results. The fast mode is suitable for "mining", while the light mode is expected to be used only for proof verification.</p>
<h2>Documentation</h2>
<p>Full specification is available in <a class="el" href="../../da/d35/specs_8md.html">specs.md</a>.</p>
<p>Design description and analysis is available in <a class="el" href="../../d1/dc3/design_8md.html">design.md</a>.</p>
<h2>Audits</h2>
<p>Between May and August 2019, RandomX was audited by 4 independent security research teams:</p>
<ul>
<li><a href="https://www.trailofbits.com/">Trail of Bits</a> (28 000 USD)</li>
<li><a href="https://www.x41-dsec.de/">X41 D-SEC</a> (42 000 EUR)</li>
<li><a href="https://www.kudelskisecurity.com/">Kudelski Security</a> (18 250 CHF)</li>
<li><a href="https://quarkslab.com/en/">QuarksLab</a> (52 800 USD)</li>
</ul>
<p>The first audit was generously funded by <a href="https://www.arweave.org/">Arweave</a>, one of the early adopters of RandomX. The remaining three audits were funded by donations from the <a href="https://ccs.getmonero.org/proposals/RandomX-audit.html">Monero community</a>. All four audits were coordinated by <a href="https://ostif.org/">OSTIF</a>.</p>
<p>Final reports from all four audits are available in the <a href="../../audits/">audits</a> directory. None of the audits found any critical vulnerabilities, but several changes in the algorithm and the code were made as a direct result of the audits. More details can be found in the <a href="https://ostif.org/four-audits-of-randomx-for-monero-and-arweave-have-been-completed-results/">final report by OSTIF</a>.</p>
<h2>Build</h2>
<p>RandomX is written in C++11 and builds a static library with a C API provided by header file <a href="../../src/randomx.h">randomx.h</a>. Minimal API usage example is provided in <a href="../../src/tests/api-example1.c">api-example1.c</a>. The reference code includes a <code>randomx-benchmark</code> and <code>randomx-tests</code> executables for testing.</p>
<h3>Linux</h3>
<p>Build dependencies: <code>cmake</code> (minimum 2.8.7) and <code>gcc</code> (minimum version 4.8, but version 7+ is recommended).</p>
<p>To build optimized binaries for your machine, run: </p><div class="fragment"><div class="line">git clone https://github.com/tevador/RandomX.git</div><div class="line">cd RandomX</div><div class="line">mkdir build &amp;&amp; cd build</div><div class="line">cmake -DARCH=native ..</div><div class="line">make</div></div><!-- fragment --><p>To build portable binaries, omit the <code>ARCH</code> option when executing cmake.</p>
<h3>Windows</h3>
<p>On Windows, it is possible to build using MinGW (same procedure as on Linux) or using Visual Studio (solution file is provided).</p>
<h3>Precompiled binaries</h3>
<p>Precompiled <code>randomx-benchmark</code> binaries are available on the <a href="https://github.com/tevador/RandomX/releases">Releases page</a>.</p>
<h2>Proof of work</h2>
<p>RandomX was primarily designed as a PoW algorithm for <a href="https://www.getmonero.org/">Monero</a>. The recommended usage is following:</p>
<ul>
<li>The key <code>K</code> is selected to be the hash of a block in the blockchain - this block is called the 'key block'. For optimal mining and verification performance, the key should change every 2048 blocks (~2.8 days) and there should be a delay of 64 blocks (~2 hours) between the key block and the change of the key <code>K</code>. This can be achieved by changing the key when <code>blockHeight % 2048 == 64</code> and selecting key block such that <code>keyBlockHeight % 2048 == 0</code>.</li>
<li>The input <code>H</code> is the standard hashing blob with a selected nonce value.</li>
</ul>
<p>RandomX was successfully activated on the <a class="el" href="../../d1/d5b/namespaceMonero.html">Monero</a> network on the 30th November 2019.</p>
<p>If you wish to use RandomX as a PoW algorithm for your cryptocurrency, please follow the <a class="el" href="../../d2/d9d/configuration_8md.html">configuration guidelines</a>.</p>
<p><b>Note</b>: To achieve ASIC resistance, the key <code>K</code> must change and must not be miner-selectable. We recommend to use blockchain data as the key in a similar way to the <a class="el" href="../../d1/d5b/namespaceMonero.html">Monero</a> example above. If blockchain data cannot be used for some reason, use a predefined sequence of keys.</p>
<h3>CPU performance</h3>
<p>The table below lists the performance of selected CPUs using the optimal number of threads (T) and large pages (if possible), in hashes per second (H/s). "CNv4" refers to the CryptoNight variant 4 (CN/R) hashrate measured using <a href="https://github.com/xmrig/xmrig">XMRig</a> v2.14.1. "Fast mode" and "Light mode" are the two modes of RandomX.</p>
<table class="doxtable">
<tr>
<th>CPU</th><th>RAM</th><th>OS</th><th>AES</th><th>CNv4</th><th>Fast mode</th><th>Light mode  </th></tr>
<tr>
<td>Intel Core i9-9900K</td><td>32G DDR4-3200</td><td>Windows 10</td><td>hw</td><td>660 (8T)</td><td>5770 (8T)</td><td>1160 (16T) </td></tr>
<tr>
<td>AMD Ryzen 7 1700</td><td>16G DDR4-2666</td><td>Ubuntu 16.04</td><td>hw</td><td>520 (8T)</td><td>4100 (8T)</td><td>620 (16T) </td></tr>
<tr>
<td>Intel Core i7-8550U</td><td>16G DDR4-2400</td><td>Windows 10</td><td>hw</td><td>200 (4T)</td><td>1700 (4T)</td><td>350 (8T) </td></tr>
<tr>
<td>Intel Core i3-3220</td><td>4G DDR3-1333</td><td>Ubuntu 16.04</td><td>soft</td><td>42 (4T)</td><td>510 (4T)</td><td>150 (4T) </td></tr>
<tr>
<td>Raspberry Pi 3</td><td>1G LPDDR2</td><td>Ubuntu 16.04</td><td>soft</td><td>3.5 (4T)</td><td>-</td><td>20 (4T) </td></tr>
</table>
<p>Note that RandomX currently includes a JIT compiler for x86-64 and ARM64. Other architectures have to use the portable interpreter, which is much slower.</p>
<h3>GPU performance</h3>
<p>SChernykh is developing GPU mining code for RandomX. Benchmarks are included in the following repositories:</p>
<ul>
<li><a href="https://github.com/SChernykh/RandomX_CUDA">CUDA miner</a> - NVIDIA GPUs.</li>
<li><a href="https://github.com/SChernykh/RandomX_OpenCL">OpenCL miner</a> - only for AMD Vega and AMD Polaris GPUs (uses GCN machine code).</li>
</ul>
<p>The code from the above repositories is included in the open source miner <a href="https://github.com/xmrig/xmrig">XMRig</a>.</p>
<p>Note that GPUs are at a disadvantage when running RandomX since the algorithm was designed to be efficient on CPUs.</p>
<h1>FAQ</h1>
<h3>Which CPU is best for mining RandomX?</h3>
<p>Most Intel and AMD CPUs made since 2011 should be fairly efficient at RandomX. More specifically, efficient mining requires:</p>
<ul>
<li>64-bit architecture</li>
<li>IEEE 754 compliant floating point unit</li>
<li>Hardware AES support (<a href="https://en.wikipedia.org/wiki/AES_instruction_set">AES-NI</a> extension for x86, Cryptography extensions for ARMv8)</li>
<li>16 KiB of L1 cache, 256 KiB of L2 cache and 2 MiB of L3 cache per mining thread</li>
<li>Support for large memory pages</li>
<li>At least 2.5 GiB of free RAM per NUMA node</li>
<li>Multiple memory channels may be required:<ul>
<li>DDR3 memory is limited to about 1500-2000 H/s per channel (depending on frequency and timings)</li>
<li>DDR4 memory is limited to about 4000-6000 H/s per channel (depending on frequency and timings)</li>
</ul>
</li>
</ul>
<h3>Does RandomX facilitate botnets/malware mining or web mining?</h3>
<p>Due to the way the algorithm works, mining malware is much easier to detect. <a href="https://github.com/tevador/randomx-sniffer">RandomX Sniffer</a> is a proof of concept tool that can detect illicit mining activity on Windows.</p>
<p>Efficient mining requires more than 2 GiB of memory, which also disqualifies many low-end machines such as IoT devices, which are often parts of large botnets.</p>
<p>Web mining is infeasible due to the large memory requirement and the lack of directed rounding support for floating point operations in both Javascript and WebAssembly.</p>
<h3>Since RandomX uses floating point math, does it give reproducible results on different platforms?</h3>
<p>RandomX uses only operations that are guaranteed to give correctly rounded results by the <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a> standard: addition, subtraction, multiplication, division and square root. Special care is taken to avoid corner cases such as NaN values or denormals.</p>
<p>The reference implementation has been validated on the following platforms:</p><ul>
<li>x86 (32-bit, little-endian)</li>
<li>x86-64 (64-bit, little-endian)</li>
<li>ARMv7+VFPv3 (32-bit, little-endian)</li>
<li>ARMv8 (64-bit, little-endian)</li>
<li>PPC64 (64-bit, big-endian)</li>
</ul>
<h3>Can FPGAs mine RandomX?</h3>
<p>RandomX generates multiple unique programs for every hash, so FPGAs cannot dynamically reconfigure their circuitry because typical FPGA takes tens of seconds to load a bitstream. It is also not possible to generate bitstreams for RandomX programs in advance due to the sheer number of combinations (there are 2<sup>512</sup> unique programs).</p>
<p>Sufficiently large FPGAs can mine RandomX in a <a href="https://en.wikipedia.org/wiki/Soft_microprocessor">soft microprocessor</a> configuration by emulating a CPU. Under these circumstances, an FPGA will be much less efficient than a CPU or a specialized chip (ASIC).</p>
<h2>Acknowledgements</h2>
<ul>
<li><a href="https://github.com/tevador">tevador</a> - author</li>
<li><a href="https://github.com/SChernykh">SChernykh</a> - contributed significantly to the design of RandomX</li>
<li><a href="https://github.com/hyc">hyc</a> - original idea of using random code execution for PoW</li>
<li><a href="https://github.com/tevador/RandomX/graphs/contributors">Other contributors</a></li>
</ul>
<p>RandomX uses some source code from the following 3rd party repositories:</p><ul>
<li>Argon2d, Blake2b hashing functions: <a href="https://github.com/P-H-C/phc-winner-argon2">https://github.com/P-H-C/phc-winner-argon2</a></li>
</ul>
<p>The author of RandomX declares no competing financial interest.</p>
<h2>Donations</h2>
<p>If you'd like to use RandomX, please consider donating to help cover the development cost of the algorithm.</p>
<p>Author's XMR address: </p><div class="fragment"><div class="line">845xHUh5GvfHwc2R8DVJCE7BT2sd4YEcmjG8GNSdmeNsP5DTEjXd1CNgxTcjHjiFuthRHAoVEJjM7GyKzQKLJtbd56xbh7V</div></div><!-- fragment --><p> Total donations received: ~3.86 XMR (as of 30th August 2019). Thanks to all contributors. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 2 2023 19:23:33 for Monero by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
